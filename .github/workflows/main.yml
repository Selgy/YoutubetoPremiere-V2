name: Build and Package

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      package_only:
        description: 'Uniquement générer les packages (utilise les derniers artefacts)'
        type: boolean
        default: false
      version:
        description: 'Version à utiliser pour la release (ex: 3.0.5)'
        required: false
        default: ''

permissions:
  contents: write
  actions: read

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      should_build: ${{ steps.check_build.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" && -n "${{ github.event.inputs.version }}" ]]; then
            echo "Version spécifiée manuellement: ${{ github.event.inputs.version }}"
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "push" && "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Version extraite du tag: $VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            else
            echo "Aucune version spécifiée, utilisation de la valeur par défaut"
            echo "version=0.0.0" >> $GITHUB_OUTPUT
            fi
      
      - name: Check if build is needed
        id: check_build
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" ]]; then
            echo "Génération des packages uniquement (skip build)"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "Build complet requis"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

  build-ffmpeg:
    needs: check-version
    if: ${{ needs.check-version.outputs.should_build == 'true' }}
    strategy:
      matrix:
        os: [windows-latest, macos-13]
      fail-fast: false
    runs-on: ${{ matrix.os }}
    outputs:
      windows_ffmpeg_path: ${{ steps.output_paths.outputs.win_ffmpeg_path }}
      macos_ffmpeg_path: ${{ steps.output_paths.outputs.mac_ffmpeg_path }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install FFmpeg (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          choco install ffmpeg -y
          cp "C:/ProgramData/chocolatey/bin/ffmpeg.exe" ./ffmpeg.exe
        shell: bash
      
      - name: Install FFmpeg (macOS)
        if: matrix.os == 'macos-13'
        run: |
          brew install ffmpeg
          cp "$(which ffmpeg)" ./ffmpeg
        shell: bash
      
      - name: Set output paths
        id: output_paths
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            echo "win_ffmpeg_path=ffmpeg.exe" >> $GITHUB_OUTPUT
          else
            echo "mac_ffmpeg_path=ffmpeg" >> $GITHUB_OUTPUT
          fi
        shell: bash
      
      - name: Upload FFmpeg
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-${{ matrix.os }}
          path: ${{ matrix.os == 'windows-latest' && 'ffmpeg.exe' || 'ffmpeg' }}
          retention-days: 90

  build-executables:
    needs: check-version
    if: ${{ needs.check-version.outputs.should_build == 'true' }}
    strategy:
      matrix:
        os: [windows-latest, macos-13]
      fail-fast: false
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
          cache: ${{ runner.os != 'Windows' && 'pip' || '' }}
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller python-socketio requests pillow python-engineio
      
      - name: Build Windows executable
        if: matrix.os == 'windows-latest'
        run: |
          # Create informative version resource
          $VERSION = "${{ needs.check-version.outputs.version }}"
          
          # Parse version components properly and create version.txt directly
          $versionParts = $VERSION.Split('.')
          # Ensure we have at least 4 parts, pad with zeros if needed
          while ($versionParts.Count -lt 4) {
            $versionParts += "0"
          }
          
          # Extract specific version parts - ensure they're treated as integers
          $part0 = [int]$versionParts[0]
          $part1 = [int]$versionParts[1]
          $part2 = [int]$versionParts[2]
          $part3 = [int]$versionParts[3]
          
          Write-Host "Creating PyInstaller version file with version: $VERSION ($part0.$part1.$part2.$part3)"
          
          # Create version file directly as a single line (no variables or Python evaluation needed)
          $content = "# UTF-8`r`n#`r`n# For more details about fixed file info 'ffi' see:`r`n# http://msdn.microsoft.com/en-us/library/ms646997.aspx`r`nVSVersionInfo(`r`n  ffi=FixedFileInfo(`r`n    filevers=($part0, $part1, $part2, $part3),`r`n    prodvers=($part0, $part1, $part2, $part3),`r`n    mask=0x3f,`r`n    flags=0x0,`r`n    OS=0x40004,`r`n    fileType=0x1,`r`n    subtype=0x0,`r`n    date=(0, 0)`r`n  ),`r`n  kids=[`r`n    StringFileInfo(`r`n      [`r`n        StringTable(`r`n          u'040904B0',`r`n          [StringStruct(u'CompanyName', u'YoutubetoPremiere'),`r`n           StringStruct(u'FileDescription', u'YouTube to Premiere Pro Extension'),`r`n           StringStruct(u'FileVersion', u'$VERSION'),`r`n           StringStruct(u'InternalName', u'YoutubetoPremiere'),`r`n           StringStruct(u'LegalCopyright', u'(c) 2024 YoutubetoPremiere'),`r`n           StringStruct(u'OriginalFilename', u'YoutubetoPremiere.exe'),`r`n           StringStruct(u'ProductName', u'YouTube to Premiere Pro'),`r`n           StringStruct(u'ProductVersion', u'$VERSION')])`r`n      ]`r`n    ),`r`n    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])`r`n  ]`r`n)"
          
          # Save version file directly
          Set-Content -Path "version.txt" -Value $content
          
          # Verify the version file was created
          if (Test-Path "version.txt") {
            $fileSize = (Get-Item -Path "version.txt").Length
            Write-Host "Version file successfully created with size: $fileSize bytes"
            # Display first few lines for verification
            Get-Content -Path "version.txt" -TotalCount 10 | ForEach-Object { Write-Host $_ }
            Write-Host "...truncated for brevity..."
          } else {
            Write-Error "Failed to create version.txt file"
            exit 1
          }
          
          # Ensure sounds directory exists
          if (!(Test-Path "app/sounds")) {
            Write-Host "Creating app/sounds directory as it doesn't exist"
            New-Item -Path "app/sounds" -ItemType Directory -Force
          }

          # Build executable with PyInstaller
          pyinstaller --name YoutubetoPremiere --onefile `
            --add-data "app/sounds;sounds" `
            --hidden-import engineio.async_drivers.threading `
            --hidden-import socketio.async_drivers.threading `
            --hidden-import pkg_resources.py2_warn `
            --version-file version.txt `
              app/YoutubetoPremiere.py
          
          # Create output directory for Python files
          New-Item -Path "dist/YoutubetoPremiere" -ItemType Directory -Force
          
          # Copy Python files
          if (Test-Path "app/*.py") {
            Copy-Item -Path "app/*.py" -Destination "dist/YoutubetoPremiere/" -Force
          }
          
          # Copy sounds directory if it exists
          if (Test-Path "app/sounds") {
            New-Item -Path "dist/YoutubetoPremiere/sounds" -ItemType Directory -Force -ErrorAction SilentlyContinue
            Copy-Item -Path "app/sounds/*" -Destination "dist/YoutubetoPremiere/sounds/" -Force -ErrorAction SilentlyContinue
          }
          
          # Create installer directory if it doesn't exist
          New-Item -Path "dist/installer" -ItemType Directory -Force
        shell: pwsh
      
      - name: Build macOS executable
        if: matrix.os == 'macos-13'
        run: |
          # Create bundle structure
            mkdir -p dist/YoutubetoPremiere.app/Contents/MacOS
            mkdir -p dist/YoutubetoPremiere.app/Contents/Resources/Python
            mkdir -p dist/YoutubetoPremiere.app/Contents/Resources/sounds
            
            # Create Info.plist
          cat > dist/YoutubetoPremiere.app/Contents/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundleExecutable</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundleIdentifier</key>
              <string>com.mickael.YoutubetoPremiere</string>
              <key>CFBundleName</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ needs.check-version.outputs.version }}</string>
              <key>NSHighResolutionCapable</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Create executable script
          cat > dist/YoutubetoPremiere.app/Contents/MacOS/YoutubetoPremiere << EOF
          #!/bin/bash
          set -e
          
          # Get the directory where this script is located
          DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
          PARENT_DIR="$( dirname "$DIR" )"
          RESOURCES_DIR="$PARENT_DIR/Resources"
          PYTHON_DIR="$RESOURCES_DIR/Python"
          
          # Find Python 3 on the system
          PYTHON_BIN=$(which python3)
          if [ ! -x "$PYTHON_BIN" ]; then
              PYTHON_BIN=$(which python)
          fi
          
          # Export environment variables
          export PYTHONPATH="$PYTHON_DIR:$PYTHONPATH"
          export PATH="$DIR:$PATH"
          
          # Run Python script
          cd "$RESOURCES_DIR"
          "$PYTHON_BIN" "$PYTHON_DIR/YoutubetoPremiere.py" "$@"
          EOF
          
          # Copy Python files and resources
          cp app/*.py dist/YoutubetoPremiere.app/Contents/Resources/Python/
          cp -r app/sounds/* dist/YoutubetoPremiere.app/Contents/Resources/sounds/ || true
            
            # Make script executable
            chmod +x dist/YoutubetoPremiere.app/Contents/MacOS/YoutubetoPremiere
            
          # Create a single binary executable for CLI use
          cat > dist/YoutubetoPremiere << EOF
          #!/bin/bash
          set -e
          
          # Get the absolute path of this script
          SCRIPT_PATH="$( cd "$(dirname "$0")" && pwd )/$(basename "$0")"
          SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
          
          # Find Python 3 on the system
          PYTHON_BIN=$(which python3)
          if [ ! -x "$PYTHON_BIN" ]; then
              PYTHON_BIN=$(which python)
          fi
          
          if [ ! -x "$PYTHON_BIN" ]; then
              echo "Error: Python 3 is required but was not found on your system."
              exit 1
          fi
          
          APP_FILE="$SCRIPT_DIR/YoutubetoPremiere.py"
          if [ ! -f "$APP_FILE" ]; then
              APP_FILE="$SCRIPT_DIR/app/YoutubetoPremiere.py"
          fi
          
          echo "Using Python: $PYTHON_BIN"
          echo "Using app file: $APP_FILE"
          
          # Run Python script with the full path
          exec "$PYTHON_BIN" "$APP_FILE" "$@"
          EOF
          
          chmod +x dist/YoutubetoPremiere
        shell: bash
        
      - name: Sign and Notarize macOS App
        if: matrix.os == 'macos-13' && env.APPLE_ID != ''
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          SIGNING_CERTIFICATE: ${{ secrets.SIGNING_CERTIFICATE }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Import certificate
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          
          echo -n "$SIGNING_CERTIFICATE" | base64 --decode -o $CERTIFICATE_PATH
          
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Import certificate
          security import $CERTIFICATE_PATH -P "$KEYCHAIN_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # Create entitlements.plist
          cat > entitlements.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Sign the app
          SIGNATURE_ID=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F '"' '{print $2}')
          
          if [[ -n "$SIGNATURE_ID" ]]; then
            echo "Signing app with identity: $SIGNATURE_ID"
            codesign --force --options runtime --entitlements entitlements.plist --sign "$SIGNATURE_ID" "dist/YoutubetoPremiere.app"
            codesign --force --options runtime --entitlements entitlements.plist --sign "$SIGNATURE_ID" "dist/YoutubetoPremiere"
            
            # Create DMG
            mkdir -p dist/dmg-contents
            cp -r dist/YoutubetoPremiere.app dist/dmg-contents/
            cp scripts/fix-macos-permissions.sh dist/dmg-contents/
            
            hdiutil create -volname "YoutubetoPremiere-${{ needs.check-version.outputs.version }}" \
              -srcfolder dist/dmg-contents \
              -ov -format UDZO \
              "dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.dmg"
            
            # Sign DMG
            codesign --force --sign "$SIGNATURE_ID" "dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.dmg"
            
            # Notarize
            xcrun notarytool submit "dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.dmg" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait
            
            # Staple
            xcrun stapler staple "dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.dmg"
          else
            echo "No signing identity found, skipping signing and notarization"
          fi
        shell: bash
        
      - name: Create Windows installer
        if: matrix.os == 'windows-latest'
        run: |
          # Install NSIS
          choco install nsis -y
          
          # Set version variable for NSIS
          $version = "${{ needs.check-version.outputs.version }}"
          $env:VERSION = $version
          
          # Create a temporary NSIS script with the version
          $nsiContent = Get-Content "installer.nsi" -Raw
          $nsiContent = $nsiContent.Replace('${VERSION}', $version)
          Set-Content -Path "installer_temp.nsi" -Value $nsiContent
          
          # Run NSIS compiler with our script
          makensis installer_temp.nsi
          
          # Verify installer was created
          if (!(Test-Path "YoutubetoPremiere-${version}-Setup.exe")) {
            Write-Error "Failed to create installer"
            exit 1
          }
          
          # Move installer to dist directory
          Move-Item "YoutubetoPremiere-${version}-Setup.exe" "dist/installer/"
          
          # Clean up temporary file
          Remove-Item "installer_temp.nsi"
        shell: pwsh
      
      - name: Upload Windows executable
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: executable-windows-latest
          path: dist/YoutubetoPremiere.exe
          retention-days: 90
      
      - name: Upload macOS executable
        if: matrix.os == 'macos-13'
        uses: actions/upload-artifact@v4
        with:
          name: executable-macos-13
          path: |
            dist/YoutubetoPremiere
            dist/YoutubetoPremiere.app/**/*
          retention-days: 90
      
      - name: Upload Windows installer
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: installer-windows
          path: dist/installer/YoutubetoPremiere-${{ needs.check-version.outputs.version }}-Setup.exe
          retention-days: 90
      
      - name: Upload macOS installer
        if: matrix.os == 'macos-13' && env.APPLE_ID != ''
        uses: actions/upload-artifact@v4
        with:
          name: installer-macos
          path: dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.dmg
          retention-days: 90

  build-zxp:
    needs: [check-version, build-executables, build-ffmpeg]
    runs-on: windows-latest
    if: always()
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'yarn'

      - name: Install dependencies
        run: |
          yarn install --frozen-lockfile
          yarn global add cross-env

      - name: Add global yarn bin to PATH
        run: echo "$(yarn global bin)" >> $GITHUB_PATH
        shell: bash

      - name: Download Executables
        uses: actions/download-artifact@v4
        with:
          path: artifacts
      
      - name: Verify Downloaded Artifacts
        run: |
          # Check if artifacts were downloaded successfully
          Write-Host "Checking downloaded artifacts..."
          
          # List files in artifacts directory
          Get-ChildItem -Path artifacts -Recurse | ForEach-Object {
            Write-Host "  $($_.FullName)"
          }
          
          # Check Windows executable
          if (Test-Path "artifacts/executable-windows-latest/YoutubetoPremiere.exe") {
            Write-Host "✅ Windows executable found"
          } else {
            Write-Host "❌ Windows executable NOT found" -ForegroundColor Red
          }
          
          # Check macOS executable
          if (Test-Path "artifacts/executable-macos-13/YoutubetoPremiere") {
            Write-Host "✅ macOS executable found"
          } else {
            Write-Host "❌ macOS executable NOT found" -ForegroundColor Red
          }
          
          # Check Windows FFmpeg
          if (Test-Path "artifacts/ffmpeg-windows-latest/ffmpeg.exe") {
            Write-Host "✅ Windows FFmpeg found"
          } else {
            Write-Host "❌ Windows FFmpeg NOT found" -ForegroundColor Red
          }
          
          # Check macOS FFmpeg
          if (Test-Path "artifacts/ffmpeg-macos-13/ffmpeg") {
            Write-Host "✅ macOS FFmpeg found"
            } else {
            Write-Host "❌ macOS FFmpeg NOT found" -ForegroundColor Red
          }
        shell: pwsh
      
      - name: Prepare files for ZXP
        run: |
          # Create required directory structure
          New-Item -Path "dist/cep/exec/sounds" -ItemType Directory -Force | Out-Null
          
          # Copy Windows executable
          if (Test-Path "artifacts/executable-windows-latest/YoutubetoPremiere.exe") {
            Copy-Item -Path "artifacts/executable-windows-latest/YoutubetoPremiere.exe" -Destination "dist/cep/exec/" -Force
            Write-Host "✅ Copied Windows executable to dist/cep/exec/"
          } else {
            Write-Host "❌ Windows executable NOT found" -ForegroundColor Red
            exit 1
          }
          
          # Copy macOS executable 
          if (Test-Path "artifacts/executable-macos-13/YoutubetoPremiere") {
            Copy-Item -Path "artifacts/executable-macos-13/YoutubetoPremiere" -Destination "dist/cep/exec/" -Force
            Write-Host "✅ Copied macOS executable to dist/cep/exec/"
            } else {
            Write-Host "❌ macOS executable NOT found" -ForegroundColor Red
            exit 1
          }
          
          # Copy FFmpeg executables
          if (Test-Path "artifacts/ffmpeg-windows-latest/ffmpeg.exe") {
            Copy-Item -Path "artifacts/ffmpeg-windows-latest/ffmpeg.exe" -Destination "dist/cep/exec/" -Force
            Write-Host "✅ Copied Windows FFmpeg to dist/cep/exec/"
              } else {
            Write-Host "❌ Windows FFmpeg NOT found" -ForegroundColor Red
            exit 1
          }
          
          if (Test-Path "artifacts/ffmpeg-macos-13/ffmpeg") {
            Copy-Item -Path "artifacts/ffmpeg-macos-13/ffmpeg" -Destination "dist/cep/exec/" -Force
            Write-Host "✅ Copied macOS FFmpeg to dist/cep/exec/"
          } else {
            Write-Host "❌ macOS FFmpeg NOT found" -ForegroundColor Red
            exit 1
          }
          
          # Copy Python files from app directory (main files)
          Write-Host "Copying Python files from app directory..."
          Get-ChildItem -Path "app" -Filter "*.py" | ForEach-Object {
            Copy-Item -Path $_.FullName -Destination "dist/cep/exec/" -Force
            Write-Host "  Copied $($_.Name) to dist/cep/exec/"
          }
          
          # Copy sounds directory from app/exec
          if (Test-Path "app/exec/sounds") {
            Write-Host "Copying sounds from app/exec/sounds..."
            Get-ChildItem -Path "app/exec/sounds" | ForEach-Object {
              Copy-Item -Path $_.FullName -Destination "dist/cep/exec/sounds/" -Force
              Write-Host "  Copied $($_.Name) to dist/cep/exec/sounds/"
            }
          } else {
            Write-Host "⚠️ Sound files directory not found at app/exec/sounds" -ForegroundColor Yellow
          }
          
          # Create fix-permissions.sh script for macOS
          Write-Host "Creating fix-permissions.sh script..."
          # Copy from existing one or create it from scratch
          if (Test-Path "app/exec/fix-permissions.sh") {
            Copy-Item -Path "app/exec/fix-permissions.sh" -Destination "dist/cep/exec/" -Force
          } else {
            # Create bash script content as a simple string
            $fixScript = "#!/bin/bash`n"
            $fixScript += "# Fix permissions for macOS executables`n"
            $fixScript += "SCRIPT_DIR=`"```$(dirname ```$0)`"`n"
            $fixScript += "chmod +x ```"```$SCRIPT_DIR/YoutubetoPremiere```" 2>/dev/null || true`n"
            $fixScript += "chmod +x ```"```$SCRIPT_DIR/ffmpeg```" 2>/dev/null || true`n"
            $fixScript += "xattr -d com.apple.quarantine ```"```$SCRIPT_DIR/YoutubetoPremiere```" 2>/dev/null || true`n"
            $fixScript += "xattr -d com.apple.quarantine ```"```$SCRIPT_DIR/ffmpeg```" 2>/dev/null || true`n"
            $fixScript += "echo ```"Permissions fixed for macOS executables```"`n"
            Set-Content -Path "dist/cep/exec/fix-permissions.sh" -Value $fixScript -NoNewline
          }
          
          # Copy README from app/exec if it exists
          if (Test-Path "app/exec/README.md") {
            Copy-Item -Path "app/exec/README.md" -Destination "dist/cep/exec/" -Force
            Write-Host "✅ Copied README.md from app/exec/"
          } else {
            Write-Host "Creating README.md..."
            # Create readme content line by line
            $readmeContent = "# YouTube to Premiere Pro Extension`n`n"
            $readmeContent += "This directory contains the executables needed for the YouTube to Premiere Pro extension.`n`n"
            $readmeContent += "## Executables`n`n"
            $readmeContent += "- YoutubetoPremiere.exe - Windows executable`n"
            $readmeContent += "- YoutubetoPremiere - macOS executable`n"
            $readmeContent += "- ffmpeg.exe - FFmpeg for Windows`n"
            $readmeContent += "- ffmpeg - FFmpeg for macOS`n"
            $readmeContent += "- fix-permissions.sh - Script to fix permissions on macOS`n`n"
            $readmeContent += "## macOS Permission Issues`n`n"
            $readmeContent += "If you encounter permission issues on macOS, run this command in Terminal:`n`n"
            $readmeContent += "```bash`n"
            $readmeContent += "chmod +x ```"/Library/Application Support/Adobe/CEP/extensions/com.youtubetoPremiereV2.cep/exec/fix-permissions.sh```"`n"
            $readmeContent += "```"/Library/Application Support/Adobe/CEP/extensions/com.youtubetoPremiereV2.cep/exec/fix-permissions.sh```"`n"
            $readmeContent += "```"
            Set-Content -Path "dist/cep/exec/README.md" -Value $readmeContent
          }
          
          # Display content of exec directory
          Write-Host "Content of exec directory:"
          Get-ChildItem -Path "dist/cep/exec" -Recurse | ForEach-Object {
            $fileSize = if ($_.PSIsContainer) { "Directory" } else { "$($_.Length) bytes" }
            $indent = "  " * ($_.FullName.Split([IO.Path]::DirectorySeparatorChar).Count - $_.FullName.Split([IO.Path]::DirectorySeparatorChar).IndexOf("exec") - 1)
            Write-Host "$indent$($_.Name) - $fileSize"
          }
        shell: pwsh
      
      - name: Build TypeScript
        run: yarn tsc -p "tsconfig-build.json"
      
      - name: Create ZXP Package
        run: |
          # Set environment variables to skip Python build
          $env:SKIP_PYTHON_BUILD = "true"
          $env:NO_PYTHON = "true"
          $env:ZXP_PACKAGE = "true"
          
          # Run ZXP packaging
          yarn zxp
          
          # Check if ZXP was created
          $zxpOriginalPath = "dist/zxp/com.youtubetoPremiereV2.cep.zxp"
          $zxpVersionedPath = "dist/zxp/YoutubetoPremiere-v${{ needs.check-version.outputs.version }}.zxp"
          
          if (Test-Path $zxpOriginalPath) {
            Write-Host "ZXP package created: $zxpOriginalPath"
            Copy-Item -Path $zxpOriginalPath -Destination $zxpVersionedPath -Force
            Write-Host "Created versioned ZXP: $zxpVersionedPath"
          } else {
            Write-Error "Failed to create ZXP package"
            exit 1
          }
        shell: pwsh

      - name: Verify ZXP Contents
        run: |
          pwsh verify-zxp-contents.ps1 "dist/zxp/YoutubetoPremiere-v${{ needs.check-version.outputs.version }}.zxp"
        shell: pwsh
      
      - name: Upload ZXP Package
        uses: actions/upload-artifact@v4
        with:
          name: zxp-package
          path: dist/zxp/YoutubetoPremiere-v${{ needs.check-version.outputs.version }}.zxp
          retention-days: 90

      - name: Create Release
        if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist/zxp/YoutubetoPremiere-v${{ needs.check-version.outputs.version }}.zxp
            artifacts/installer-windows/YoutubetoPremiere-${{ needs.check-version.outputs.version }}-Setup.exe
            artifacts/installer-macos/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.dmg
          name: YoutubetoPremiere v${{ needs.check-version.outputs.version }}
          tag_name: v${{ needs.check-version.outputs.version }}
          generate_release_notes: true