name: Build and Package

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      package_only:
        description: 'Only run the packaging step (uses latest successful build artifacts)'
        type: boolean
        default: false
      version:
        description: 'Version to use for the release (e.g. 3.0.5)'
        required: false
        default: ''

permissions:
  contents: write
  actions: read

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.filter.outputs.app_changed }}
      tag_version: ${{ steps.get_version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check if package_only is enabled
        id: check_package_only
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" ]]; then
            echo "package_only=true" >> $GITHUB_OUTPUT
            if [[ -n "${{ github.event.inputs.version }}" ]]; then
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
            else
              # Default to the latest tag if no version is specified
              latest_tag=$(git describe --tags --abbrev=0)
              echo "version=${latest_tag#v}" >> $GITHUB_OUTPUT
            fi
          else
            echo "package_only=false" >> $GITHUB_OUTPUT
          fi
        shell: bash

      - name: Check for app changes
        id: filter
        run: |
          if [[ "${{ steps.check_package_only.outputs.package_only }}" == "true" ]]; then
            echo "Skipping change detection as package_only is enabled"
            echo "app_changed=true" >> $GITHUB_OUTPUT
          else
            # Normal change detection
            if [[ "${{ github.event_name }}" == "push" && "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ]]; then
              echo "app_changed=true" >> $GITHUB_OUTPUT
            else
              echo "No app changes detected or not a tagged push event"
              echo "app_changed=false" >> $GITHUB_OUTPUT
            fi
          fi
        shell: bash

      - name: Extract version from tag or input
        id: get_version
        run: |
          if [[ "${{ steps.check_package_only.outputs.package_only }}" == "true" ]]; then
            echo "version=${{ steps.check_package_only.outputs.version }}" >> $GITHUB_OUTPUT
          else
            if [[ "${{ github.event_name }}" == "push" && "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ]]; then
              version=${GITHUB_REF#refs/tags/v}
              echo "version=$version" >> $GITHUB_OUTPUT
            else
              echo "version=0.0.0" >> $GITHUB_OUTPUT
            fi
          fi
        shell: bash

  build-ffmpeg:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.app_changed == 'true' && github.event.inputs.package_only != 'true' }}
    strategy:
      matrix:
        os: [windows-latest, macos-13]
      fail-fast: false
    runs-on: ${{ matrix.os }}
    outputs:
      windows_ffmpeg_path: ${{ steps.output_paths.outputs.win_ffmpeg_path }}
      macos_ffmpeg_path: ${{ steps.output_paths.outputs.mac_ffmpeg_path }}
    steps:
      - name: Check FFmpeg cache
        id: check_artifacts
        run: |
          # First check if artifacts exist from previous successful runs
          ARTIFACT_EXISTS=false

          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARTIFACT_NAME="ffmpeg-windows-latest"
          else
            ARTIFACT_NAME="ffmpeg-macos-13"
          fi

          echo "Checking for artifact: $ARTIFACT_NAME"
          
          # Try to download the artifact using GitHub API
          ARTIFACTS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts?name=$ARTIFACT_NAME")
          
          # Check if artifacts exist and are not expired
          ARTIFACT_COUNT=$(echo $ARTIFACTS_RESPONSE | jq '.total_count')
          
          if [[ "$ARTIFACT_COUNT" -gt 0 ]]; then
            echo "Found $ARTIFACT_COUNT existing artifact(s)"
            ARTIFACT_EXISTS=true
          else
            echo "No existing artifacts found"
          fi
          
          echo "artifact_exists=$ARTIFACT_EXISTS" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Download existing artifact
        if: steps.check_artifacts.outputs.artifact_exists == 'true'
        uses: dawidd6/action-download-artifact@v2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: main.yml
          workflow_conclusion: success
          name: ${{ matrix.os == 'windows-latest' && 'ffmpeg-windows-latest' || 'ffmpeg-macos-13' }}
          path: existing-artifact
      
      - name: Verify downloaded artifact
        if: steps.check_artifacts.outputs.artifact_exists == 'true'
        id: verify_artifact
        run: |
          ARTIFACT_VALID=false
          
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            if [ -f "existing-artifact/ffmpeg.exe" ]; then
              echo "Found valid Windows FFmpeg in artifact"
              ARTIFACT_VALID=true
            fi
          else
            if [ -f "existing-artifact/ffmpeg" ]; then
              echo "Found valid macOS FFmpeg in artifact"
              ARTIFACT_VALID=true
            fi
          fi
          
          echo "artifact_valid=$ARTIFACT_VALID" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Output paths
        id: output_paths
        run: |
          if [ "${{ matrix.os }}" = "windows-latest" ]; then
            echo "win_ffmpeg_path=ffmpeg.exe" >> $GITHUB_OUTPUT
          else
            echo "mac_ffmpeg_path=ffmpeg" >> $GITHUB_OUTPUT
          fi
        shell: bash
      
      # Only run the rest of the steps if artifacts don't exist or are invalid
      - name: Checkout repository
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        uses: actions/checkout@v4
      
      - name: Install FFmpeg through package manager
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        id: package_install
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            choco install ffmpeg -y
            cp "C:/ProgramData/chocolatey/bin/ffmpeg.exe" ./ffmpeg.exe
          else
            brew install ffmpeg
            cp "$(which ffmpeg)" ./ffmpeg
          fi
          echo "FFmpeg installed successfully"
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ls -la ./ffmpeg.exe || echo "Windows FFmpeg not found"
          else
            ls -la ./ffmpeg || echo "macOS FFmpeg not found"
          fi
        shell: bash
      
      - name: Upload FFmpeg
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-${{ matrix.os }}
          path: ${{ matrix.os == 'windows-latest' && 'ffmpeg.exe' || 'ffmpeg' }}
          retention-days: 90
      
      # Use existing artifact if it exists and is valid
      - name: Prepare existing artifact for upload
        if: steps.check_artifacts.outputs.artifact_exists == 'true' && steps.verify_artifact.outputs.artifact_valid == 'true'
        run: |
          mkdir -p .
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp existing-artifact/ffmpeg.exe ./
            echo "Reusing existing Windows FFmpeg"
          else
            cp existing-artifact/ffmpeg ./
            echo "Reusing existing macOS FFmpeg"
          fi
          echo "Content of current directory:"
          ls -la .
        shell: bash
      
      - name: Re-upload existing artifact
        if: steps.check_artifacts.outputs.artifact_exists == 'true' && steps.verify_artifact.outputs.artifact_valid == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ffmpeg-${{ matrix.os }}
          path: ${{ matrix.os == 'windows-latest' && 'ffmpeg.exe' || 'ffmpeg' }}
          retention-days: 90

  build-executables:
    needs: check-changes
    if: ${{ needs.check-changes.outputs.app_changed == 'true' && github.event.inputs.package_only != 'true' }}
    strategy:
      matrix:
        os: [windows-latest, macos-13]
      fail-fast: false
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Check for existing artifacts
        id: check_artifacts
        run: |
          # First check if artifacts exist from previous successful runs
          ARTIFACT_EXISTS=false

          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARTIFACT_NAME="executable-windows-latest"
          else
            ARTIFACT_NAME="executable-macos-13"
          fi

          echo "Checking for artifact: $ARTIFACT_NAME"
          
          # Try to download the artifact using GitHub API
          ARTIFACTS_RESPONSE=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/actions/artifacts?name=$ARTIFACT_NAME")
          
          # Check if artifacts exist and are not expired
          ARTIFACT_COUNT=$(echo $ARTIFACTS_RESPONSE | jq '.total_count')
          
          if [[ "$ARTIFACT_COUNT" -gt 0 ]]; then
            echo "Found $ARTIFACT_COUNT existing artifact(s)"
            ARTIFACT_EXISTS=true
          else
            echo "No existing artifacts found"
          fi
          
          echo "artifact_exists=$ARTIFACT_EXISTS" >> $GITHUB_OUTPUT
        shell: bash
      
      - name: Download existing artifact
        if: steps.check_artifacts.outputs.artifact_exists == 'true'
        uses: dawidd6/action-download-artifact@v2
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          workflow: main.yml
          workflow_conclusion: success
          name: ${{ matrix.os == 'windows-latest' && 'executable-windows-latest' || 'executable-macos-13' }}
          path: existing-artifact
      
      - name: Verify downloaded artifact
        if: steps.check_artifacts.outputs.artifact_exists == 'true'
        id: verify_artifact
        run: |
          ARTIFACT_VALID=false
          
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            if [ -f "existing-artifact/YoutubetoPremiere.exe" ]; then
              echo "Found valid Windows executable in artifact"
              ARTIFACT_VALID=true
            fi
          else
            if [ -f "existing-artifact/YoutubetoPremiere" ]; then
              echo "Found valid macOS executable in artifact"
              ARTIFACT_VALID=true
            fi
          fi
          
          echo "artifact_valid=$ARTIFACT_VALID" >> $GITHUB_OUTPUT
        shell: bash
      
      # Only run the rest of the steps if artifacts don't exist or are invalid
      - name: Setup Python
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
          cache: 'pip'
          
      - name: Install Python dependencies
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller python-socketio requests pillow
      
      - name: Check Platform
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        id: platform
        run: |
          echo "Building for ${{ matrix.os }}"
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            echo "is_windows=true" >> $GITHUB_OUTPUT
          else
            echo "is_windows=false" >> $GITHUB_OUTPUT
          fi
        shell: bash
      
      - name: Clean Python caches on Windows
        if: ${{ steps.platform.outputs.is_windows == 'true' && (steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true') }}
        run: |
          Remove-Item -Path $env:LOCALAPPDATA\pip\Cache -Recurse -Force -ErrorAction SilentlyContinue
          Write-Host "Cleared pip cache"
        shell: pwsh

      - name: Build executable with PyInstaller
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        run: |
          echo "Working directory: $(pwd)"
          echo "Content of app directory:"
          ls -la app/
          
          # Create the spec file based on the platform
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # Windows spec
            python -m PyInstaller --name YoutubetoPremiere --onefile app/YoutubetoPremiere.py
          else
            # macOS spec
            python -m PyInstaller --name YoutubetoPremiere --onefile app/YoutubetoPremiere.py
          fi
          
          echo "PyInstaller completed"
          echo "Content of dist directory:"
          ls -la dist/
        shell: bash
      
      - name: Upload executable artifact
        if: steps.check_artifacts.outputs.artifact_exists != 'true' || steps.verify_artifact.outputs.artifact_valid != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: executable-${{ matrix.os }}
          path: dist/YoutubetoPremiere*
          retention-days: 90
      
      # Use existing artifact if it exists and is valid
      - name: Prepare existing artifact for upload
        if: steps.check_artifacts.outputs.artifact_exists == 'true' && steps.verify_artifact.outputs.artifact_valid == 'true'
        run: |
          mkdir -p dist
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp existing-artifact/YoutubetoPremiere.exe dist/
            echo "Reusing existing Windows executable"
          else
            cp existing-artifact/YoutubetoPremiere dist/
            echo "Reusing existing macOS executable"
          fi
          echo "Content of dist directory:"
          ls -la dist/
        shell: bash
      
      - name: Re-upload existing artifact
        if: steps.check_artifacts.outputs.artifact_exists == 'true' && steps.verify_artifact.outputs.artifact_valid == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: executable-${{ matrix.os }}
          path: dist/YoutubetoPremiere*
          retention-days: 90

  package-zxp:
    needs: [check-changes, build-ffmpeg, build-executables]
    if: ${{ needs.check-changes.outputs.app_changed == 'true' }}
    runs-on: windows-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'yarn'

      - name: Install dependencies
        run: |
          yarn install --frozen-lockfile
          yarn global add cross-env
        
      - name: Add global yarn bin to PATH
        run: echo "$(yarn global bin)" >> $GITHUB_PATH
        shell: bash
      
      - name: Create directories
        run: |
          mkdir -p dist/cep/exec/sounds
          mkdir -p backup/exec
        shell: bash

      - name: Download artifacts from current workflow
        if: ${{ github.event.inputs.package_only != 'true' }}
        uses: actions/download-artifact@v4
        
      - name: Download artifacts from previous workflow
        if: ${{ github.event.inputs.package_only == 'true' }}
        uses: dawidd6/action-download-artifact@v2
        with:
          github_token: ${{secrets.GITHUB_TOKEN}}
          workflow: main.yml
          workflow_conclusion: success
          name_is_regexp: true
          name: .*
          path: artifacts
      
      - name: List downloaded artifacts
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" ]]; then
            find artifacts -type f | sort
          else
            ls -la
          fi
        shell: bash

      - name: Optimize ZXP packaging process
        shell: bash
        env:
          SKIP_PYTHON_BUILD: true
          NO_PYTHON: true
          ZXP_PACKAGE: true
          SKIP_FILE_COPY: true
        run: |
          # Function to copy artifacts with error checking
          copy_artifact() {
            local source=$1
            local dest=$2
            local description=$3
            
            if [ -f "$source" ]; then
              # Use cp -p to preserve permissions
              cp -p "$source" "$dest"
              
              # For macOS executables, ensure they have execute permissions
              if [[ "$source" == *"macos"* ]] || [[ "$source" != *".exe" ]]; then
                chmod +x "$dest/$(basename "$source")"
                # Verify the permissions were set
                if [ -x "$dest/$(basename "$source")" ]; then
                  echo "✓ Set execute permissions for $description"
                else
                  echo "✗ WARNING: Failed to set execute permissions for $description"
                fi
              fi
              
              echo "✓ Copied $description"
              
              # Verify the file exists and has the correct size
              if [ -f "$dest/$(basename "$source")" ]; then
                local source_size=$(stat -f%z "$source" 2>/dev/null || stat -c%s "$source")
                local dest_size=$(stat -f%z "$dest/$(basename "$source")" 2>/dev/null || stat -c%s "$dest/$(basename "$source")")
                if [ "$source_size" = "$dest_size" ]; then
                  echo "✓ Verified $description (size: $source_size bytes)"
                else
                  echo "✗ WARNING: Size mismatch for $description"
                  echo "  Source: $source_size bytes"
                  echo "  Destination: $dest_size bytes"
                fi
              else
                echo "✗ ERROR: Failed to copy $description"
                return 1
              fi
            else
              echo "✗ ERROR: $description not found at: $source"
              return 1
            fi
          }
          
          echo "===== PREPARING ZXP PACKAGE ====="
          
          # Create backup of executables
          mkdir -p backup/exec
          mkdir -p dist
          
          # Copy all Python files with preserved permissions
          echo "Copying Python files..."
          cp -p app/*.py dist/cep/exec/ 2>/dev/null || echo "No Python files found"
          cp -rp app/sounds/* dist/cep/exec/sounds/ 2>/dev/null || echo "No sound files found"
          
          # Copy artifacts efficiently
          echo "Copying executables and FFmpeg..."
          
          # Windows executable
          copy_artifact "executable-windows-latest/YoutubetoPremiere.exe" "dist/cep/exec/" "Windows executable to CEP"
          copy_artifact "executable-windows-latest/YoutubetoPremiere.exe" "backup/exec/" "Windows executable to backup"
          copy_artifact "executable-windows-latest/YoutubetoPremiere.exe" "dist/" "Windows executable to dist"
          
          # Windows FFmpeg
          copy_artifact "ffmpeg-windows-latest/ffmpeg.exe" "dist/cep/exec/" "Windows FFmpeg to CEP"
          copy_artifact "ffmpeg-windows-latest/ffmpeg.exe" "backup/exec/" "Windows FFmpeg to backup"
          copy_artifact "ffmpeg-windows-latest/ffmpeg.exe" "dist/" "Windows FFmpeg to dist"
          
          # macOS executable
          copy_artifact "executable-macos-13/YoutubetoPremiere" "dist/cep/exec/" "macOS executable to CEP"
          copy_artifact "executable-macos-13/YoutubetoPremiere" "backup/exec/" "macOS executable to backup"
          copy_artifact "executable-macos-13/YoutubetoPremiere" "dist/" "macOS executable to dist"
          
          # macOS FFmpeg
          copy_artifact "ffmpeg-macos-13/ffmpeg" "dist/cep/exec/" "macOS FFmpeg to CEP"
          copy_artifact "ffmpeg-macos-13/ffmpeg" "backup/exec/" "macOS FFmpeg to backup"
          copy_artifact "ffmpeg-macos-13/ffmpeg" "dist/" "macOS FFmpeg to dist"
          
          # Verify files in place and permissions
          echo "Verifying files in dist/cep/exec before yarn zxp:"
          ls -la dist/cep/exec
          
          echo "Verifying files in dist directory:"
          ls -la dist
          
          # Build TypeScript
          echo "Building TypeScript..."
          yarn tsc -p "tsconfig-build.json"
          
          # Create initial ZXP
          echo "Running initial yarn zxp..."
          yarn zxp
          
          # Verify the ZXP exists
          if [ ! -f "dist/zxp/com.youtubetoPremiereV2.cep.zxp" ]; then
            echo "ERROR: yarn zxp did not create the ZXP package"
            exit 1
          fi
          
          echo "Extracting the ZXP package..."
          mkdir -p zxp_extract
          cp dist/zxp/com.youtubetoPremiereV2.cep.zxp zxp_extract/
          cd zxp_extract
          unzip -q com.youtubetoPremiereV2.cep.zxp -d contents || echo "Could not extract ZXP"
          cd ..
          
          echo "Creating exec directory in the extracted package..."
          mkdir -p zxp_extract/contents/exec
          
          echo "Copying executables to the extracted package..."
          cp -p backup/exec/* zxp_extract/contents/exec/ 2>/dev/null || echo "No executables found in backup"
          cp -p app/*.py zxp_extract/contents/exec/ 2>/dev/null || echo "No Python files found"
          mkdir -p zxp_extract/contents/exec/sounds
          cp -rp app/sounds/* zxp_extract/contents/exec/sounds/ 2>/dev/null || echo "No sound files found"
          
          # Ensure proper permissions for macOS executables
          chmod +x zxp_extract/contents/exec/YoutubetoPremiere 2>/dev/null || true
          chmod +x zxp_extract/contents/exec/ffmpeg 2>/dev/null || true
          
          echo "Verifying executables are in the extracted package:"
          ls -la zxp_extract/contents/exec
          
          echo "===== ZXP PACKAGING COMPLETED ====="

      - name: Create Final ZXP with Executables
        shell: pwsh
        run: |
          Write-Host "===== CREATING FINAL ZXP WITH EXECUTABLES ====="
          
          # Get the absolute path of the workspace
          $workspacePath = Get-Location
          Write-Host "Current workspace path: $workspacePath"
          
          # Check for executables in artifact directories first
          $winExeSource = Join-Path $workspacePath "executable-windows-latest/YoutubetoPremiere.exe"
          $macExeSource = Join-Path $workspacePath "executable-macos-13/YoutubetoPremiere"
          $winFfmpegSource = Join-Path $workspacePath "ffmpeg-windows-latest/ffmpeg.exe"
          $macFfmpegSource = Join-Path $workspacePath "ffmpeg-macos-13/ffmpeg"
          
          Write-Host "Checking for source files:"
          Write-Host "Windows executable: $winExeSource"
          Write-Host "macOS executable: $macExeSource"
          Write-Host "Windows FFmpeg: $winFfmpegSource"
          Write-Host "macOS FFmpeg: $macFfmpegSource"
          
          # Function to copy a file with checking
          function Copy-FileWithCheck {
            param (
              [string]$Source,
              [string]$Destination
            )
            
            if (Test-Path $Source) {
              Write-Host "Copying $Source to $Destination"
              Copy-Item -Path $Source -Destination $Destination -Force
              
              if (Test-Path $Destination) {
                $sourceSize = (Get-Item $Source).Length
                $destSize = (Get-Item $Destination).Length
                
                if ($sourceSize -eq $destSize) {
                  Write-Host "✓ Successfully copied $(Split-Path $Source -Leaf) ($sourceSize bytes)"
                  return $true
                } else {
                  Write-Host "✗ WARNING: Size mismatch after copying $(Split-Path $Source -Leaf)"
                  Write-Host "  Source: $sourceSize bytes"
                  Write-Host "  Destination: $destSize bytes"
                  return $false
                }
              } else {
                Write-Host "✗ WARNING: Failed to copy $(Split-Path $Source -Leaf) to $Destination"
                return $false
              }
            } else {
              Write-Host "✗ WARNING: Source file not found: $Source"
              return $false
            }
          }
          
          # Create fresh ZXP directory structure
          $outputDir = Join-Path $workspacePath "zxp_output"
          if (Test-Path $outputDir) {
            Remove-Item -Path $outputDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
          Write-Host "Created output directory: $outputDir"
          
          # Create necessary directories
          $execDir = Join-Path $outputDir "exec"
          $jsDir = Join-Path $outputDir "js"
          $jsxDir = Join-Path $outputDir "jsx"
          $assetsDir = Join-Path $outputDir "assets"
          $csxsDir = Join-Path $outputDir "CSXS"
          $mainDir = Join-Path $outputDir "main"
          $settingsDir = Join-Path $outputDir "settings"
          $soundsDir = Join-Path $execDir "sounds"
          
          New-Item -ItemType Directory -Path $execDir -Force | Out-Null
          New-Item -ItemType Directory -Path $jsDir -Force | Out-Null
          New-Item -ItemType Directory -Path $jsxDir -Force | Out-Null
          New-Item -ItemType Directory -Path $assetsDir -Force | Out-Null
          New-Item -ItemType Directory -Path $csxsDir -Force | Out-Null
          New-Item -ItemType Directory -Path $mainDir -Force | Out-Null
          New-Item -ItemType Directory -Path $settingsDir -Force | Out-Null
          New-Item -ItemType Directory -Path $soundsDir -Force | Out-Null
          
          # Copy built files from dist directory if they exist
          if (Test-Path "dist/cep") {
            Write-Host "Copying built files from dist/cep directory..."
            Copy-Item -Path "dist/cep/*" -Destination $outputDir -Force -Recurse
          } else {
            Write-Host "dist/cep directory doesn't exist, building only with executables"
            
            # Copy basic structure from src
            if (Test-Path "src") {
              Write-Host "Copying basic structure from src directory..."
              # Create simple HTML files
              @"
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>YouTube to Premiere</title>
</head>
<body>
  <div id="app"></div>
</body>
</html>
"@ | Out-File -FilePath (Join-Path $mainDir "index.html") -Encoding utf8
              
              @"
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>YouTube to Premiere - Settings</title>
</head>
<body>
  <div id="app"></div>
</body>
</html>
"@ | Out-File -FilePath (Join-Path $settingsDir "index.html") -Encoding utf8
              
              # Create simple manifest
              @"
<?xml version="1.0" encoding="UTF-8"?>
<ExtensionManifest Version="6.0" ExtensionBundleId="com.youtubetoPremiereV2.cep" ExtensionBundleVersion="3.0.0" ExtensionBundleName="YoutubetoPremiere">
  <ExtensionList>
    <Extension Id="com.youtubetoPremiereV2.cep.main" Version="3.0.0" />
    <Extension Id="com.youtubetoPremiereV2.cep.settings" Version="3.0.0" />
  </ExtensionList>
  <ExecutionEnvironment>
    <HostList>
      <Host Name="PPRO" Version="[22.0,99.9]" />
    </HostList>
    <LocaleList>
      <Locale Code="All" />
    </LocaleList>
    <RequiredRuntimeList>
      <RequiredRuntime Name="CSXS" Version="9.0" />
    </RequiredRuntimeList>
  </ExecutionEnvironment>
  <DispatchInfoList>
    <Extension Id="com.youtubetoPremiereV2.cep.main">
      <DispatchInfo>
        <Resources>
          <MainPath>./main/index.html</MainPath>
          <ScriptPath>./jsx/index.js</ScriptPath>
          <CEFCommandLine>
            <Parameter>--allow-file-access-from-files</Parameter>
            <Parameter>--allow-file-access</Parameter>
            <Parameter>--disable-web-security</Parameter>
          </CEFCommandLine>
        </Resources>
        <Lifecycle>
          <AutoVisible>true</AutoVisible>
        </Lifecycle>
        <UI>
          <Type>Panel</Type>
          <Menu>YouTube to Premiere Pro</Menu>
          <Geometry>
            <Size>
              <Height>600</Height>
              <Width>600</Width>
            </Size>
          </Geometry>
        </UI>
      </DispatchInfo>
    </Extension>
    <Extension Id="com.youtubetoPremiereV2.cep.settings">
      <DispatchInfo>
        <Resources>
          <MainPath>./settings/index.html</MainPath>
          <ScriptPath>./jsx/index.js</ScriptPath>
          <CEFCommandLine>
            <Parameter>--allow-file-access-from-files</Parameter>
            <Parameter>--allow-file-access</Parameter>
            <Parameter>--disable-web-security</Parameter>
          </CEFCommandLine>
        </Resources>
        <Lifecycle>
          <AutoVisible>true</AutoVisible>
        </Lifecycle>
        <UI>
          <Type>ModalDialog</Type>
          <Menu>YouTube to Premiere Pro Settings</Menu>
          <Geometry>
            <Size>
              <Height>400</Height>
              <Width>400</Width>
            </Size>
          </Geometry>
        </UI>
      </DispatchInfo>
    </Extension>
  </DispatchInfoList>
</ExtensionManifest>
"@ | Out-File -FilePath (Join-Path $csxsDir "manifest.xml") -Encoding utf8
              
              # Create .debug file
              @"
<?xml version="1.0" encoding="UTF-8"?>
<ExtensionList>
  <Extension Id="com.youtubetoPremiereV2.cep.main">
    <HostList>
      <Host Name="PPRO" Port="8080" />
    </HostList>
  </Extension>
  <Extension Id="com.youtubetoPremiereV2.cep.settings">
    <HostList>
      <Host Name="PPRO" Port="8081" />
    </HostList>
  </Extension>
</ExtensionList>
"@ | Out-File -FilePath (Join-Path $outputDir ".debug") -Encoding utf8
              
              # Copy Python source files
              Get-ChildItem -Path "app/*.py" -ErrorAction SilentlyContinue | ForEach-Object {
                Copy-Item -Path $_.FullName -Destination $execDir -Force
              }
            }
          }
          
          # Copy the executables to the exec directory
          Copy-FileWithCheck -Source $winExeSource -Destination "$execDir/YoutubetoPremiere.exe"
          Copy-FileWithCheck -Source $macExeSource -Destination "$execDir/YoutubetoPremiere"
          Copy-FileWithCheck -Source $winFfmpegSource -Destination "$execDir/ffmpeg.exe"
          Copy-FileWithCheck -Source $macFfmpegSource -Destination "$execDir/ffmpeg"
          
          # Set permissions for macOS files
          Write-Host "Setting permissions for macOS files..."
          & "bash" "-c" "chmod +x `"$execDir/YoutubetoPremiere`" 2>/dev/null || true"
          & "bash" "-c" "chmod +x `"$execDir/ffmpeg`" 2>/dev/null || true"
          
          # List contents of exec directory
          Write-Host "Contents of $execDir directory:"
          Get-ChildItem -Path $execDir | ForEach-Object { Write-Host "  - $($_.Name) ($($_.Length) bytes)" }
          
          # Create output directory for ZXP
          New-Item -ItemType Directory -Path "dist/zxp" -Force | Out-Null
          
          # Create the ZXP using simple ZIP compression to ensure it completes quickly
          Write-Host "Creating ZXP package..."
          $zxpPath = Join-Path $workspacePath "dist/zxp/com.youtubetoPremiereV2.cep.zxp"
          
          # Delete the existing ZXP if it exists
          if (Test-Path $zxpPath) {
            Remove-Item -Path $zxpPath -Force
          }
          
          # Create the ZXP (which is just a ZIP file with .zxp extension)
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          [System.IO.Compression.ZipFile]::CreateFromDirectory($outputDir, $zxpPath)
          
          # Verify the ZXP was created
          if (Test-Path $zxpPath) {
            $fileSize = (Get-Item $zxpPath).Length / 1MB
            Write-Host "✓ ZXP package created successfully: $fileSize MB"
            
            # List the contents of the ZXP to verify
            Write-Host "Verifying executables in the ZXP package:"
            $zipFile = [System.IO.Compression.ZipFile]::OpenRead($zxpPath)
            $execFiles = $zipFile.Entries | Where-Object { $_.FullName -like "exec/*" -and $_.Name -match "(YoutubetoPremiere|ffmpeg)($|\.exe$)" }
            
            if ($execFiles.Count -gt 0) {
              Write-Host "✓ Found executables in ZXP:"
              foreach ($file in $execFiles) {
                Write-Host "  - $($file.FullName)"
              }
              
              $macFiles = $execFiles | Where-Object { $_.Name -notmatch "\.exe$" }
              if ($macFiles.Count -gt 0) {
                Write-Host "✓ Found macOS executables in ZXP:"
                foreach ($file in $macFiles) {
                  Write-Host "  - $($file.FullName)"
                }
              } else {
                Write-Host "✗ WARNING: No macOS executables found in ZXP!"
              }
            } else {
              Write-Host "✗ WARNING: No executables found in ZXP!"
            }
            
            $zipFile.Dispose()
          } else {
            Write-Error "Failed to create ZXP package!"
            exit 1
          }
          
          # Clean up the temporary directory
          Remove-Item -Path $outputDir -Recurse -Force -ErrorAction SilentlyContinue
          
          Write-Host "===== FINAL ZXP PACKAGING COMPLETED ====="

      - name: Verify and Rename ZXP Package
        shell: pwsh
        run: |
          $version = "${{ needs.check-changes.outputs.tag_version }}"
          
          if (Test-Path "dist/zxp/com.youtubetoPremiereV2.cep.zxp") {
            # Rename the ZXP file to include the version
            $newName = "YoutubetoPremiere-v$version.zxp"
            Copy-Item -Path "dist/zxp/com.youtubetoPremiereV2.cep.zxp" -Destination "dist/zxp/$newName" -Force
            Write-Host "Renamed ZXP package to: $newName"
            
            # Remove the original file
            Remove-Item -Path "dist/zxp/com.youtubetoPremiereV2.cep.zxp" -Force
            
            # List the files
            Get-ChildItem -Path dist/zxp
          } else {
            Write-Error "ZXP package was not found!"
            exit 1
          }

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: ./dist/zxp/YoutubetoPremiere-v${{ needs.check-changes.outputs.tag_version }}.zxp
          name: YoutubetoPremiere v${{ needs.check-changes.outputs.tag_version }}
          tag_name: v${{ needs.check-changes.outputs.tag_version }}
          generate_release_notes: true
