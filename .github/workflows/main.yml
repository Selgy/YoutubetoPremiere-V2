name: Build and Package

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      package_only:
        description: 'Uniquement générer les packages (utilise les derniers artefacts)'
        type: boolean
        default: false
      version:
        description: 'Version à utiliser pour la release (ex: 3.0.5)'
        required: false
        default: ''

permissions:
  contents: write
  actions: read

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      should_build: ${{ steps.check_build.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" && -n "${{ github.event.inputs.version }}" ]]; then
            echo "Version spécifiée manuellement: ${{ github.event.inputs.version }}"
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "push" && "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Version extraite du tag: $VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            else
            echo "Aucune version spécifiée, utilisation de la valeur par défaut"
              echo "version=0.0.0" >> $GITHUB_OUTPUT
            fi
      
      - name: Check if build is needed
        id: check_build
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" ]]; then
            echo "Génération des packages uniquement (skip build)"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "Build complet requis"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

  build-executables:
    needs: check-version
    if: ${{ needs.check-version.outputs.should_build == 'true' }}
    strategy:
      matrix:
        os: [windows-latest, macos-13]
      fail-fast: false
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
          cache: ${{ runner.os != 'Windows' && 'pip' || '' }}
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller python-socketio requests pillow python-engineio
      
      - name: Build Windows executable
        if: matrix.os == 'windows-latest'
        run: |
          # Create informative version resource
          $VERSION = "${{ needs.check-version.outputs.version }}"
          
          # Parse version components properly and create version.txt directly
          $versionParts = $VERSION.Split('.')
          # Ensure we have at least 4 parts, pad with zeros if needed
          while ($versionParts.Count -lt 4) {
            $versionParts += "0"
          }
          
          # Extract specific version parts - ensure they're treated as integers
          $part0 = [int]$versionParts[0]
          $part1 = [int]$versionParts[1]
          $part2 = [int]$versionParts[2]
          $part3 = [int]$versionParts[3]
          
          Write-Host "Creating PyInstaller version file with version: $VERSION ($part0.$part1.$part2.$part3)"
          
          # Create version file directly as a single line (no variables or Python evaluation needed)
          $content = "# UTF-8`r`n#`r`n# For more details about fixed file info 'ffi' see:`r`n# http://msdn.microsoft.com/en-us/library/ms646997.aspx`r`nVSVersionInfo(`r`n  ffi=FixedFileInfo(`r`n    filevers=($part0, $part1, $part2, $part3),`r`n    prodvers=($part0, $part1, $part2, $part3),`r`n    mask=0x3f,`r`n    flags=0x0,`r`n    OS=0x40004,`r`n    fileType=0x1,`r`n    subtype=0x0,`r`n    date=(0, 0)`r`n  ),`r`n  kids=[`r`n    StringFileInfo(`r`n      [`r`n        StringTable(`r`n          u'040904B0',`r`n          [StringStruct(u'CompanyName', u'YoutubetoPremiere'),`r`n           StringStruct(u'FileDescription', u'YouTube to Premiere Pro Extension'),`r`n           StringStruct(u'FileVersion', u'$VERSION'),`r`n           StringStruct(u'InternalName', u'YoutubetoPremiere'),`r`n           StringStruct(u'LegalCopyright', u'(c) 2024 YoutubetoPremiere'),`r`n           StringStruct(u'OriginalFilename', u'YoutubetoPremiere.exe'),`r`n           StringStruct(u'ProductName', u'YouTube to Premiere Pro'),`r`n           StringStruct(u'ProductVersion', u'$VERSION')])`r`n      ]`r`n    ),`r`n    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])`r`n  ]`r`n)"
          
          # Save version file directly
          Set-Content -Path "version.txt" -Value $content
          
          # Verify the version file was created
          if (Test-Path "version.txt") {
            $fileSize = (Get-Item -Path "version.txt").Length
            Write-Host "Version file successfully created with size: $fileSize bytes"
            # Display first few lines for verification
            Get-Content -Path "version.txt" -TotalCount 10 | ForEach-Object { Write-Host $_ }
            Write-Host "...truncated for brevity..."
          } else {
            Write-Error "Failed to create version.txt file"
            exit 1
          }
          
          # Ensure sounds directory exists
          if (!(Test-Path "app/sounds")) {
            Write-Host "Creating app/sounds directory as it doesn't exist"
            New-Item -Path "app/sounds" -ItemType Directory -Force
          }

          # Build executable with PyInstaller
          pyinstaller --name YoutubetoPremiere --onefile `
            --add-data "app/sounds;sounds" `
            --hidden-import engineio.async_drivers.threading `
            --hidden-import socketio.async_drivers.threading `
            --hidden-import pkg_resources.py2_warn `
            --version-file version.txt `
              app/YoutubetoPremiere.py
          
          # Create output directory for Python files
          New-Item -Path "dist/YoutubetoPremiere" -ItemType Directory -Force
          
          # Copy Python files
          if (Test-Path "app/*.py") {
            Copy-Item -Path "app/*.py" -Destination "dist/YoutubetoPremiere/" -Force
          }
          
          # Copy sounds directory if it exists
          if (Test-Path "app/sounds") {
            New-Item -Path "dist/YoutubetoPremiere/sounds" -ItemType Directory -Force -ErrorAction SilentlyContinue
            Copy-Item -Path "app/sounds/*" -Destination "dist/YoutubetoPremiere/sounds/" -Force -ErrorAction SilentlyContinue
          }
          
          # Create installer directory if it doesn't exist
          New-Item -Path "dist/installer" -ItemType Directory -Force
        shell: pwsh
      
      - name: Build macOS executable
        if: matrix.os == 'macos-13'
        run: |
          # Create bundle structure
            mkdir -p dist/YoutubetoPremiere.app/Contents/MacOS
            mkdir -p dist/YoutubetoPremiere.app/Contents/Resources/Python
            mkdir -p dist/YoutubetoPremiere.app/Contents/Resources/sounds
            
            # Create Info.plist
          cat > dist/YoutubetoPremiere.app/Contents/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundleExecutable</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundleIdentifier</key>
              <string>com.mickael.YoutubetoPremiere</string>
              <key>CFBundleName</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ needs.check-version.outputs.version }}</string>
              <key>NSHighResolutionCapable</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Create executable script
          cat > dist/YoutubetoPremiere.app/Contents/MacOS/YoutubetoPremiere << EOF
          #!/bin/bash
          set -e
          
          # Get the directory where this script is located
          DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
          PARENT_DIR="$( dirname "$DIR" )"
          RESOURCES_DIR="$PARENT_DIR/Resources"
          PYTHON_DIR="$RESOURCES_DIR/Python"
          
          # Find Python 3 on the system
          PYTHON_BIN=$(which python3)
          if [ ! -x "$PYTHON_BIN" ]; then
              PYTHON_BIN=$(which python)
          fi
          
          # Export environment variables
          export PYTHONPATH="$PYTHON_DIR:$PYTHONPATH"
          export PATH="$DIR:$PATH"
          
          # Run Python script
          cd "$RESOURCES_DIR"
          "$PYTHON_BIN" "$PYTHON_DIR/YoutubetoPremiere.py" "$@"
          EOF
          
          # Copy Python files and resources
          cp app/*.py dist/YoutubetoPremiere.app/Contents/Resources/Python/
          
          # Copy sounds directory if it exists
          if [ -d "app/sounds" ] && [ "$(ls -A app/sounds 2>/dev/null)" ]; then
            echo "Copying sound files..."
            cp -r app/sounds/* dist/YoutubetoPremiere.app/Contents/Resources/sounds/ || echo "Note: No sound files copied (directory may be empty)"
          else
            echo "Sound directory doesn't exist or is empty, creating empty directory"
            mkdir -p app/sounds
            touch app/sounds/.gitkeep
          fi
            
            # Make script executable
            chmod +x dist/YoutubetoPremiere.app/Contents/MacOS/YoutubetoPremiere
            
          # Create a single binary executable for CLI use
          cat > dist/YoutubetoPremiere << EOF
          #!/bin/bash
          set -e
          
          # Get the absolute path of this script
          SCRIPT_PATH="$( cd "$(dirname "$0")" && pwd )/$(basename "$0")"
          SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
          
          # Find Python 3 on the system
          PYTHON_BIN=$(which python3)
          if [ ! -x "$PYTHON_BIN" ]; then
              PYTHON_BIN=$(which python)
          fi
          
          if [ ! -x "$PYTHON_BIN" ]; then
              echo "Error: Python 3 is required but was not found on your system."
              exit 1
          fi
          
          APP_FILE="$SCRIPT_DIR/YoutubetoPremiere.py"
          if [ ! -f "$APP_FILE" ]; then
              APP_FILE="$SCRIPT_DIR/app/YoutubetoPremiere.py"
          fi
          
          echo "Using Python: $PYTHON_BIN"
          echo "Using app file: $APP_FILE"
          
          # Run Python script with the full path
          exec "$PYTHON_BIN" "$APP_FILE" "$@"
          EOF
          
          chmod +x dist/YoutubetoPremiere
        shell: bash
        
      - name: Import Certificate
        if: matrix.os == 'macos-13'
        env:
          SIGNING_CERTIFICATE: ${{ secrets.SIGNING_CERTIFICATE }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # Check if we have the Apple ID
          if [ -z "$APPLE_ID" ]; then
            echo "No Apple ID found, skipping signing"
            exit 0
          fi
          
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          
          echo -n "$SIGNING_CERTIFICATE" | base64 --decode -o "$CERTIFICATE_PATH"
          
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Import certificate
          security import "$CERTIFICATE_PATH" -P "$KEYCHAIN_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Signal to subsequent steps that certificate is imported
          echo "CERTIFICATE_IMPORTED=true" >> $GITHUB_ENV
        shell: bash
          
      - name: Create Entitlements File
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true'
        run: |
          cat > entitlements.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF
        shell: bash
      
      - name: Sign macOS App
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # Sign the app
          SIGNATURE_ID=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F '"' '{print $2}')
          
          if [[ -n "$SIGNATURE_ID" ]]; then
            echo "Signing app with identity: $SIGNATURE_ID"
            codesign --force --options runtime --entitlements entitlements.plist --sign "$SIGNATURE_ID" "dist/YoutubetoPremiere.app"
            codesign --force --options runtime --entitlements entitlements.plist --sign "$SIGNATURE_ID" "dist/YoutubetoPremiere"
            
            # Create a simple temp file to track signature was successful
            echo "$SIGNATURE_ID" > dist/signature.info
          else
            echo "No signing identity found, skipping signing"
          fi
        shell: bash
      
      - name: Create macOS Package
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true'
        env:
          VERSION: ${{ needs.check-version.outputs.version }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # Check if we have a signature ID from previous step
          if [ -f "dist/signature.info" ]; then
            SIGNATURE_ID=$(cat dist/signature.info)
            
            echo "Creating PKG with signature: $SIGNATURE_ID"
            
            # Create PKG directly
            pkgbuild --component "dist/YoutubetoPremiere.app" \
                    --install-location "/Applications" \
                    --identifier "com.mickael.YoutubetoPremiere" \
                    --version "$VERSION" \
                    --sign "$SIGNATURE_ID" \
                    "dist/YoutubetoPremiere-$VERSION.pkg"
            
            # Remove signature info file
            rm -f dist/signature.info
            
            # Signal to subsequent steps that pkg was created
            echo "PKG_CREATED=true" >> $GITHUB_ENV
          else
            echo "No signature ID found, skipping package creation"
          fi
        shell: bash
      
      - name: Notarize and Staple macOS Package
        if: matrix.os == 'macos-13' && env.PKG_CREATED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          VERSION: ${{ needs.check-version.outputs.version }}
        run: |
          if [ -f "dist/YoutubetoPremiere-$VERSION.pkg" ]; then
            # Notarize the package
            xcrun notarytool submit "dist/YoutubetoPremiere-$VERSION.pkg" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait
            
            # Staple the package
            xcrun stapler staple "dist/YoutubetoPremiere-$VERSION.pkg"
          else
            echo "Package not found, skipping notarization"
          fi
        shell: bash
      
      - name: Create Windows installer
        if: matrix.os == 'windows-latest'
        run: |
          # Install NSIS
          choco install nsis -y
          
          # Set version variable for NSIS
          $version = "${{ needs.check-version.outputs.version }}"
          $env:VERSION = $version
          
          # Create a temporary NSIS script with the version
          $nsiContent = Get-Content "installer.nsi" -Raw
          $nsiContent = $nsiContent.Replace('${VERSION}', $version)
          Set-Content -Path "installer_temp.nsi" -Value $nsiContent
          
          # Run NSIS compiler with our script
          makensis installer_temp.nsi
          
          # Verify installer was created
          if (!(Test-Path "YoutubetoPremiere-$version-Setup.exe")) {
            Write-Error "Failed to create installer"
            exit 1
          }
          
          # Create installer directory if it doesn't exist
          New-Item -Path "dist/installer" -ItemType Directory -Force -ErrorAction SilentlyContinue
          
          # Move installer to dist directory
          Move-Item "YoutubetoPremiere-$version-Setup.exe" "dist/installer/" -Force
          
          # Clean up temporary file
          Remove-Item "installer_temp.nsi" -ErrorAction SilentlyContinue
        shell: pwsh
      
      - name: Upload Windows executable
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: executable-windows-latest
          path: dist/YoutubetoPremiere.exe
          retention-days: 90
      
      - name: Upload macOS executable
        if: matrix.os == 'macos-13'
        uses: actions/upload-artifact@v4
        with:
          name: executable-macos-13
          path: |
            dist/YoutubetoPremiere
            dist/YoutubetoPremiere.app/**/*
          retention-days: 90
      
      - name: Upload Windows installer
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: installer-windows
          path: dist/installer/YoutubetoPremiere-${{ needs.check-version.outputs.version }}-Setup.exe
          retention-days: 90

      - name: Upload macOS installer
        if: matrix.os == 'macos-13' && env.PKG_CREATED == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: installer-macos
          path: dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.pkg
          retention-days: 90

  create-release:
    needs: [check-version, build-executables]
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    steps:
      - name: Create directories for artifacts
        run: |
          mkdir -p dist/windows
          mkdir -p dist/macos
        shell: bash

      - name: Download Windows installer
        uses: actions/download-artifact@v4
        with:
          name: installer-windows
          path: dist/windows
        
      - name: Download macOS installer
        uses: actions/download-artifact@v4
        with:
          name: installer-macos
          path: dist/macos
      
      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          ls -la dist/
          find dist -type f | sort
        shell: bash

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist/windows/YoutubetoPremiere-${{ needs.check-version.outputs.version }}-Setup.exe
            dist/macos/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.pkg
          name: YoutubetoPremiere v${{ needs.check-version.outputs.version }}
          tag_name: v${{ needs.check-version.outputs.version }}
          generate_release_notes: true