name: Build and Package

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      package_only:
        description: 'Uniquement générer les packages (utilise les derniers artefacts)'
        type: boolean
        default: false
      version:
        description: 'Version à utiliser pour la release (ex: 3.0.5)'
        required: false
        default: ''

permissions:
  contents: write
  actions: read

jobs:
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      should_build: ${{ steps.check_build.outputs.should_build }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Extract version
        id: get_version
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" && -n "${{ github.event.inputs.version }}" ]]; then
            echo "Version spécifiée manuellement: ${{ github.event.inputs.version }}"
              echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "push" && "${{ startsWith(github.ref, 'refs/tags/v') }}" == "true" ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "Version extraite du tag: $VERSION"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            else
            echo "Aucune version spécifiée, utilisation de la valeur par défaut"
              echo "version=0.0.0" >> $GITHUB_OUTPUT
            fi
      
      - name: Check if build is needed
        id: check_build
        run: |
          if [[ "${{ github.event.inputs.package_only }}" == "true" ]]; then
            echo "Génération des packages uniquement (skip build)"
            echo "should_build=false" >> $GITHUB_OUTPUT
          else
            echo "Build complet requis"
            echo "should_build=true" >> $GITHUB_OUTPUT
          fi

  build-executables:
    needs: check-version
    if: ${{ needs.check-version.outputs.should_build == 'true' }}
    strategy:
      matrix:
        os: [windows-latest, macos-13]
      fail-fast: false
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'
          cache: ${{ runner.os != 'Windows' && 'pip' || '' }}
      
      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyinstaller python-socketio requests pillow python-engineio
      
      - name: Build Windows executable
        if: matrix.os == 'windows-latest'
        run: |
          # Create informative version resource
          $VERSION = "${{ needs.check-version.outputs.version }}"
          
          # Parse version components properly and create version.txt directly
          $versionParts = $VERSION.Split('.')
          # Ensure we have at least 4 parts, pad with zeros if needed
          while ($versionParts.Count -lt 4) {
            $versionParts += "0"
          }
          
          # Extract specific version parts - ensure they're treated as integers
          $part0 = [int]$versionParts[0]
          $part1 = [int]$versionParts[1]
          $part2 = [int]$versionParts[2]
          $part3 = [int]$versionParts[3]
          
          Write-Host "Creating PyInstaller version file with version: $VERSION ($part0.$part1.$part2.$part3)"
          
          # Create version file directly as a single line (no variables or Python evaluation needed)
          $content = "# UTF-8`r`n#`r`n# For more details about fixed file info 'ffi' see:`r`n# http://msdn.microsoft.com/en-us/library/ms646997.aspx`r`nVSVersionInfo(`r`n  ffi=FixedFileInfo(`r`n    filevers=($part0, $part1, $part2, $part3),`r`n    prodvers=($part0, $part1, $part2, $part3),`r`n    mask=0x3f,`r`n    flags=0x0,`r`n    OS=0x40004,`r`n    fileType=0x1,`r`n    subtype=0x0,`r`n    date=(0, 0)`r`n  ),`r`n  kids=[`r`n    StringFileInfo(`r`n      [`r`n        StringTable(`r`n          u'040904B0',`r`n          [StringStruct(u'CompanyName', u'YoutubetoPremiere'),`r`n           StringStruct(u'FileDescription', u'YouTube to Premiere Pro Extension'),`r`n           StringStruct(u'FileVersion', u'$VERSION'),`r`n           StringStruct(u'InternalName', u'YoutubetoPremiere'),`r`n           StringStruct(u'LegalCopyright', u'(c) 2024 YoutubetoPremiere'),`r`n           StringStruct(u'OriginalFilename', u'YoutubetoPremiere.exe'),`r`n           StringStruct(u'ProductName', u'YouTube to Premiere Pro'),`r`n           StringStruct(u'ProductVersion', u'$VERSION')])`r`n      ]`r`n    ),`r`n    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])`r`n  ]`r`n)"
          
          # Save version file directly
          Set-Content -Path "version.txt" -Value $content
          
          # Verify the version file was created
          if (Test-Path "version.txt") {
            $fileSize = (Get-Item -Path "version.txt").Length
            Write-Host "Version file successfully created with size: $fileSize bytes"
            # Display first few lines for verification
            Get-Content -Path "version.txt" -TotalCount 10 | ForEach-Object { Write-Host $_ }
            Write-Host "...truncated for brevity..."
          } else {
            Write-Error "Failed to create version.txt file"
            exit 1
          }
          
          # Ensure sounds directory exists
          if (!(Test-Path "app/sounds")) {
            Write-Host "Creating app/sounds directory as it doesn't exist"
            New-Item -Path "app/sounds" -ItemType Directory -Force
          }

          # Build executable with PyInstaller
          pyinstaller --name YoutubetoPremiere --onefile `
            --add-data "app/sounds;sounds" `
            --hidden-import engineio.async_drivers.threading `
            --hidden-import socketio.async_drivers.threading `
            --hidden-import pkg_resources.py2_warn `
            --version-file version.txt `
              app/YoutubetoPremiere.py
          
          # Download FFmpeg for Windows
          Write-Host "Downloading FFmpeg for Windows..."
          Invoke-WebRequest -Uri "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip" -OutFile "ffmpeg.zip"
          Expand-Archive -Path "ffmpeg.zip" -DestinationPath "ffmpeg_temp"
          
          # Create proper directory structure for CEP extension
          $cepPath = "dist/YoutubetoPremiere/CEP"
          $execPath = "dist/YoutubetoPremiere/exec"
          
          # Create directory structure
          New-Item -Path $cepPath -ItemType Directory -Force
          New-Item -Path $execPath -ItemType Directory -Force
          
          # Copy extension files to CEP directory if they exist
          if (Test-Path "extension") {
            Copy-Item -Path "extension/*" -Destination $cepPath -Recurse -Force
          }
          
          # Copy main executable to exec directory
          Copy-Item -Path "dist/YoutubetoPremiere.exe" -Destination $execPath -Force
          
          # Copy FFmpeg to exec directory
          $ffmpegExe = Get-ChildItem -Path "ffmpeg_temp" -Filter "ffmpeg.exe" -Recurse | Select-Object -First 1
          if ($ffmpegExe) {
            Copy-Item -Path $ffmpegExe.FullName -Destination "$execPath/ffmpeg.exe" -Force
            Write-Host "FFmpeg copied to $execPath/ffmpeg.exe"
          } else {
            Write-Error "Could not find ffmpeg.exe in the downloaded package"
          }
          
          # Copy Python files
          if (Test-Path "app/*.py") {
            Copy-Item -Path "app/*.py" -Destination "dist/YoutubetoPremiere/" -Force
          }
          
          # Copy sounds directory if it exists
          if (Test-Path "app/sounds") {
            New-Item -Path "dist/YoutubetoPremiere/sounds" -ItemType Directory -Force -ErrorAction SilentlyContinue
            Copy-Item -Path "app/sounds/*" -Destination "dist/YoutubetoPremiere/sounds/" -Force -ErrorAction SilentlyContinue
          }
          
          # Create installer directory if it doesn't exist
          New-Item -Path "dist/installer" -ItemType Directory -Force
          
          # Create version file for installer
          $versionFile = "dist/YoutubetoPremiere/version.txt"
          Set-Content -Path $versionFile -Value $VERSION
          
          # Final check of the distribution directory
          Write-Host "Distribution directory contents:"
          Get-ChildItem -Path "dist/YoutubetoPremiere" -Recurse | ForEach-Object { Write-Host $_.FullName }
        shell: pwsh
      
      - name: Build macOS executable
        if: matrix.os == 'macos-13'
        run: |
          # Create bundle structure
          mkdir -p dist/YoutubetoPremiere.app/Contents/MacOS
          mkdir -p dist/YoutubetoPremiere.app/Contents/Resources/Python
          mkdir -p dist/YoutubetoPremiere.app/Contents/Resources/sounds
          
          # Create CEP and exec directories
          mkdir -p dist/YoutubetoPremiere/CEP
          mkdir -p dist/YoutubetoPremiere/exec
          
          # Download FFmpeg for macOS
          echo "Downloading FFmpeg for macOS..."
          curl -L https://evermeet.cx/ffmpeg/getrelease/ffmpeg/zip -o ffmpeg.zip
          unzip -q ffmpeg.zip -d ffmpeg_temp
          
          # Move FFmpeg to the correct locations
          chmod +x ffmpeg_temp/ffmpeg
          mkdir -p dist/YoutubetoPremiere/exec
          cp ffmpeg_temp/ffmpeg dist/YoutubetoPremiere/exec/
          
          # Also copy ffmpeg to the app bundle
          mkdir -p dist/YoutubetoPremiere.app/Contents/MacOS/
          cp ffmpeg_temp/ffmpeg dist/YoutubetoPremiere.app/Contents/MacOS/
            
          # Create Info.plist
          cat > dist/YoutubetoPremiere.app/Contents/Info.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>CFBundleDisplayName</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundleExecutable</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundleIdentifier</key>
              <string>com.mickael.YoutubetoPremiere</string>
              <key>CFBundleName</key>
              <string>YoutubetoPremiere</string>
              <key>CFBundlePackageType</key>
              <string>APPL</string>
              <key>CFBundleShortVersionString</key>
              <string>${{ needs.check-version.outputs.version }}</string>
              <key>NSHighResolutionCapable</key>
              <true/>
          </dict>
          </plist>
          EOF
          
          # Create executable script
          cat > dist/YoutubetoPremiere.app/Contents/MacOS/YoutubetoPremiere << EOF
          #!/bin/bash
          set -e
          
          # Get the directory where this script is located
          DIR="\$( cd "\$( dirname "\${BASH_SOURCE[0]}" )" && pwd )"
          PARENT_DIR="\$( dirname "\$DIR" )"
          RESOURCES_DIR="\$PARENT_DIR/Resources"
          PYTHON_DIR="\$RESOURCES_DIR/Python"
          
          # Find Python 3 on the system
          PYTHON_BIN=\$(which python3)
          if [ ! -x "\$PYTHON_BIN" ]; then
              PYTHON_BIN=\$(which python)
          fi
          
          # Export environment variables
          export PYTHONPATH="\$PYTHON_DIR:\$PYTHONPATH"
          export PATH="\$DIR:\$PATH"
          
          # Run Python script
          cd "\$RESOURCES_DIR"
          "\$PYTHON_BIN" "\$PYTHON_DIR/YoutubetoPremiere.py" "\$@"
          EOF
          
          # Copy Python files and resources
          cp app/*.py dist/YoutubetoPremiere.app/Contents/Resources/Python/
          
          # Also copy the app files to the exec directory
          cp app/*.py dist/YoutubetoPremiere/exec/
          
          # Copy the bundle to exec directory for backup
          cp -r dist/YoutubetoPremiere.app dist/YoutubetoPremiere/exec/
          
          # Copy sounds directory if it exists
          if [ -d "app/sounds" ] && [ "$(ls -A app/sounds 2>/dev/null)" ]; then
            echo "Copying sound files..."
            cp -r app/sounds/* dist/YoutubetoPremiere.app/Contents/Resources/sounds/ || echo "Note: No sound files copied (directory may be empty)"
            # Also copy to main app directory
            mkdir -p dist/YoutubetoPremiere/sounds
            cp -r app/sounds/* dist/YoutubetoPremiere/sounds/ || echo "Note: No sound files copied (directory may be empty)"
          else
            echo "Sound directory doesn't exist or is empty, creating empty directory"
            mkdir -p app/sounds
            touch app/sounds/.gitkeep
            mkdir -p dist/YoutubetoPremiere/sounds
          fi
          
          # Copy extension files to CEP directory if they exist
          if [ -d "extension" ]; then
            echo "Copying extension files to CEP directory..."
            cp -r extension/* dist/YoutubetoPremiere/CEP/ || echo "Note: No extension files copied"
          fi
            
          # Make script executable
          chmod +x dist/YoutubetoPremiere.app/Contents/MacOS/YoutubetoPremiere
            
          # Create a single binary executable for CLI use
          mkdir -p dist/bin
          cat > dist/bin/YoutubetoPremiere << EOF
          #!/bin/bash
          set -e
          
          # Get the absolute path of this script
          SCRIPT_PATH="\$( cd "\$(dirname "\$0")" && pwd )/\$(basename "\$0")"
          SCRIPT_DIR="\$(dirname "\$SCRIPT_PATH")"
          PARENT_DIR="\$(dirname "\$SCRIPT_DIR")"
          
          # Find Python 3 on the system
          PYTHON_BIN=\$(which python3)
          if [ ! -x "\$PYTHON_BIN" ]; then
              PYTHON_BIN=\$(which python)
          fi
          
          if [ ! -x "\$PYTHON_BIN" ]; then
              echo "Error: Python 3 is required but was not found on your system."
              exit 1
          fi
          
          APP_FILE="\$PARENT_DIR/YoutubetoPremiere/exec/YoutubetoPremiere.py"
          if [ ! -f "\$APP_FILE" ]; then
              APP_FILE="\$PARENT_DIR/YoutubetoPremiere/app/YoutubetoPremiere.py"
          fi
          
          echo "Using Python: \$PYTHON_BIN"
          echo "Using app file: \$APP_FILE"
          
          # Run Python script with the full path
          exec "\$PYTHON_BIN" "\$APP_FILE" "\$@"
          EOF
          
          chmod +x dist/bin/YoutubetoPremiere
          
          # Copy executable to exec directory
          mkdir -p dist/YoutubetoPremiere/exec
          cp dist/bin/YoutubetoPremiere dist/YoutubetoPremiere/exec/
          cp dist/bin/YoutubetoPremiere dist/
          
          # Create version file for installer
          echo "${{ needs.check-version.outputs.version }}" > dist/YoutubetoPremiere/version.txt
          
          # Final check of the distribution directory
          echo "Distribution directory contents:"
          find dist/YoutubetoPremiere -type f | sort
        shell: bash
        
      - name: Import Certificate
        if: matrix.os == 'macos-13'
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # Check if we have the Apple ID
          if [ -z "$APPLE_ID" ]; then
            echo "No Apple ID found, skipping signing"
            exit 0
          fi
          
          CERTIFICATE_PATH="$RUNNER_TEMP/certificate.p12"
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          
          echo -n "$MACOS_CERTIFICATE" | base64 --decode -o "$CERTIFICATE_PATH"
          
          # Check p12 certificate details
          echo "Checking p12 certificate info (password required to view details):"
          openssl pkcs12 -info -in "$CERTIFICATE_PATH" -nokeys -passin "pass:$KEYCHAIN_PASSWORD" || echo "Unable to show certificate info"
          
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # Import certificate
          echo "Importing certificate to keychain..."
          security import "$CERTIFICATE_PATH" -P "$KEYCHAIN_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          
          # List certificates in keychain
          echo "Certificates in keychain after import:"
          security find-identity -v -p codesigning || true
          
          # Signal to subsequent steps that certificate is imported
          echo "CERTIFICATE_IMPORTED=true" >> $GITHUB_ENV
        shell: bash

      - name: Create Entitlements File
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true'
        run: |
          cat > entitlements.plist << 'EOF'
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>com.apple.security.cs.allow-jit</key>
              <true/>
              <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
              <true/>
              <key>com.apple.security.network.client</key>
              <true/>
              <key>com.apple.security.files.user-selected.read-write</key>
              <true/>
          </dict>
          </plist>
          EOF
        shell: bash

      - name: Sign macOS App
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # List all available certificates for debugging
          echo "Available signing certificates:"
          security find-identity -v -p codesigning || true
          
          # Try to find a Developer ID Application certificate first
          SIGNATURE_ID=$(security find-identity -v -p codesigning | grep "Developer ID Application" | head -1 | awk -F '"' '{print $2}' || echo "")
          
          # If not found, try to use any available certificate
          if [[ -z "$SIGNATURE_ID" ]]; then
            echo "No Developer ID Application certificate found, trying to use any available certificate"
            SIGNATURE_ID=$(security find-identity -v -p codesigning | head -1 | sed -E 's/.*([0-9A-F]{40}).*/\1/' || echo "")
          fi
          
          if [[ -n "$SIGNATURE_ID" ]]; then
            echo "Signing app with identity: $SIGNATURE_ID"
            codesign --force --options runtime --entitlements entitlements.plist --sign "$SIGNATURE_ID" "dist/YoutubetoPremiere.app" || echo "Warning: App signing failed but continuing"
            codesign --force --options runtime --entitlements entitlements.plist --sign "$SIGNATURE_ID" "dist/bin/YoutubetoPremiere" || echo "Warning: CLI signing failed but continuing"
            
            # Create a simple temp file to track signature was successful
            echo "$SIGNATURE_ID" > dist/signature.info
          else
            echo "No signing identity found, creating unsigned app"
            touch dist/signature.info
            echo "UNSIGNED" > dist/signature.info
          fi
          
          # Always indicate success for next steps
          echo "APP_PREPARED=true" >> $GITHUB_ENV
        shell: bash

      - name: Prepare macOS Package Script
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true' && env.APP_PREPARED == 'true'
        env:
          VERSION: ${{ needs.check-version.outputs.version }}
        run: |
          cat > create_macos_package.sh << 'EOF'
          #!/bin/bash
          
          VERSION=$1
          
          # Check if signature info exists (will exist even for unsigned app now)
          if [ ! -f "dist/signature.info" ]; then
            echo "No signature info found, skipping package creation"
            exit 0
          fi
          
          # Get signature info
          APP_SIGNATURE_ID=$(cat dist/signature.info)
          echo "App signature info: $APP_SIGNATURE_ID"
          
          # List all available certificates for debugging with multiple commands
          echo "Available certificates (codesigning):"
          security find-identity -v -p codesigning || true
          
          echo "Available certificates (ALL):"
          security find-identity -v || true
          
          echo "Complete certificate list from keychain:"
          security find-certificate -a -p -Z /Users/runner/work/_temp/app-signing.keychain-db | grep "Subject Name" || true
          
          # Create component packages for the different parts of the application
          echo "Creating component packages..."
          
          # Create directory for package components
          mkdir -p "dist/pkgbuild/flat"
          mkdir -p "dist/pkgbuild/root/Applications"
          mkdir -p "dist/pkgbuild/root/Library/Application Support/Adobe/CEP/extensions/com.youtubetopremiere"
          
          # Copy files to package root
          echo "Copying files to package root..."
          cp -R "dist/YoutubetoPremiere.app" "dist/pkgbuild/root/Applications/"
          cp -R "dist/YoutubetoPremiere/exec" "dist/pkgbuild/root/Applications/YoutubetoPremiere.app/Contents/Resources/" || echo "No exec files to copy"
          cp -R "dist/YoutubetoPremiere/CEP/"* "dist/pkgbuild/root/Library/Application Support/Adobe/CEP/extensions/com.youtubetopremiere/" || echo "No CEP files to copy"
          
          # Create distribution XML
          cat > "dist/pkgbuild/distribution.xml" << EOXML
          <?xml version="1.0" encoding="utf-8"?>
          <installer-gui-script minSpecVersion="1">
              <title>YouTube to Premiere Pro</title>
              <organization>YoutubetoPremiere</organization>
              <domains enable_localSystem="true"/>
              <options customize="never" require-scripts="false"/>
              <license file="LICENSE"/>
              <background alignment="center" file="background.png" scaling="proportional"/>
              <welcome file="welcome.html" mime-type="text/html"/>
              <conclusion file="conclusion.html" mime-type="text/html"/>
              <pkg-ref id="com.mickael.YoutubetoPremiere"/>
              <choices-outline>
                  <line choice="default">
                      <line choice="com.mickael.YoutubetoPremiere"/>
                  </line>
              </choices-outline>
              <choice id="default"/>
              <choice id="com.mickael.YoutubetoPremiere" visible="false">
                  <pkg-ref id="com.mickael.YoutubetoPremiere"/>
              </choice>
              <pkg-ref id="com.mickael.YoutubetoPremiere" version="${VERSION}" onConclusion="none">components.pkg</pkg-ref>
          </installer-gui-script>
          EOXML
          
          # Create resources for the installer
          mkdir -p "dist/pkgbuild/resources"
          
          # Create LICENSE file
          cat > "dist/pkgbuild/resources/LICENSE" << EOLICENSE
          YouTube to Premiere Pro
          Version ${VERSION}
          
          Copyright © 2024 YoutubetoPremiere. All rights reserved.
          
          This software allows you to download videos from YouTube and import them directly into Adobe Premiere Pro.
          EOLICENSE
          
          # Create welcome file
          cat > "dist/pkgbuild/resources/welcome.html" << EOWELCOME
          <!DOCTYPE html>
          <html>
          <head>
              <meta charset="utf-8">
              <title>Welcome</title>
              <style>
                  body { font-family: Helvetica, sans-serif; font-size: 13px; }
                  h1 { font-size: 18px; }
              </style>
          </head>
          <body>
              <h1>Welcome to YouTube to Premiere Pro</h1>
              <p>This installer will install YouTube to Premiere Pro ${VERSION} on your computer.</p>
              <p>This extension allows you to download videos from YouTube and import them directly into Adobe Premiere Pro.</p>
          </body>
          </html>
          EOWELCOME
          
          # Create conclusion file
          cat > "dist/pkgbuild/resources/conclusion.html" << EOCONCLUSION
          <!DOCTYPE html>
          <html>
          <head>
              <meta charset="utf-8">
              <title>Installation Complete</title>
              <style>
                  body { font-family: Helvetica, sans-serif; font-size: 13px; }
                  h1 { font-size: 18px; }
              </style>
          </head>
          <body>
              <h1>Installation Complete</h1>
              <p>YouTube to Premiere Pro has been successfully installed.</p>
              <p>To use the extension, open Adobe Premiere Pro and look for the YouTube to Premiere Pro panel in the Extensions menu.</p>
          </body>
          </html>
          EOCONCLUSION
          
          # Create a transparent background image
          convert -size 600x400 xc:transparent "dist/pkgbuild/resources/background.png" || echo "Skipping background image creation"
          
          # Create unsigned package first
          echo "Creating component package..."
          pkgbuild --root "dist/pkgbuild/root" \
                  --identifier "com.mickael.YoutubetoPremiere" \
                  --version "$VERSION" \
                  --install-location "/" \
                  "dist/pkgbuild/flat/components.pkg" || {
                    ERROR_CODE=$?
                    echo "Failed to create component package, error code: $ERROR_CODE"
                    ls -la dist/pkgbuild/root
                  }
                  
          # Create the product archive
          echo "Creating product archive..."
          productbuild --distribution "dist/pkgbuild/distribution.xml" \
                      --resources "dist/pkgbuild/resources" \
                      --package-path "dist/pkgbuild/flat" \
                      "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" || {
                        ERROR_CODE=$?
                        echo "Failed to create product archive, error code: $ERROR_CODE"
                        echo "Trying simpler package build..."
                        
                        # Try a simpler package if the distribution-based one fails
                        pkgbuild --component "dist/YoutubetoPremiere.app" \
                                --install-location "/Applications" \
                                --identifier "com.mickael.YoutubetoPremiere" \
                                --version "$VERSION" \
                                "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" || {
                                  ERROR_CODE=$?
                                  echo "All package creation attempts failed, error code: $ERROR_CODE"
                                  echo "Contents of dist directory:"
                                  ls -la dist/
                                }
                      }
          
          # If unsigned package created successfully, try signed version
          if [ -f "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" ]; then
            echo "Unsigned package created successfully"
            
            # Try multiple ways to find a suitable installer certificate
            echo "Looking for installer certificate..."
            
            # Method 1: Standard approach
            INSTALLER_SIGNATURE_ID=$(security find-identity -v -p codesigning | grep "Developer ID Installer" | head -1 | awk -F '"' '{print $2}' || echo "")
            
            # Method 2: If not found, try checking all identities
            if [[ -z "$INSTALLER_SIGNATURE_ID" ]]; then
              echo "Trying alternate methods to find installer certificate..."
              INSTALLER_SIGNATURE_ID=$(security find-identity -v | grep "Developer ID Installer" | head -1 | awk -F '"' '{print $2}' || echo "")
            fi
            
            # Method 3: If still not found, try using App signature as a last resort
            if [[ -z "$INSTALLER_SIGNATURE_ID" && "$APP_SIGNATURE_ID" != "UNSIGNED" ]]; then
              echo "No installer certificate found, trying to use app certificate as fallback"
              INSTALLER_SIGNATURE_ID="$APP_SIGNATURE_ID"
            fi
            
            # If signing ID available, try to create signed package
            if [[ -n "$INSTALLER_SIGNATURE_ID" && "$APP_SIGNATURE_ID" != "UNSIGNED" ]]; then
              echo "Creating signed PKG with signature: $INSTALLER_SIGNATURE_ID"
              
              # Try to create signed package but don't fail if it doesn't work
              productsign --sign "$INSTALLER_SIGNATURE_ID" \
                        "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" \
                        "dist/YoutubetoPremiere-$VERSION.pkg" || {
                          ERROR_CODE=$?
                          echo "Failed to create signed package, error code: $ERROR_CODE"
                          echo "Trying with explicit sign option..."
                          
                          # Try with explicit sign option
                          productsign --sign "Developer ID Installer: mickael ducatez" \
                                     "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" \
                                     "dist/YoutubetoPremiere-$VERSION.pkg" || {
                                      ERROR_CODE=$?
                                      echo "All signing attempts failed, error code: $ERROR_CODE"
                                      echo "Falling back to unsigned package"
                                      cp "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" "dist/YoutubetoPremiere-$VERSION.pkg"
                                     }
                        }
            else
              echo "No suitable signing identity found, using unsigned package"
              cp "dist/YoutubetoPremiere-$VERSION-unsigned.pkg" "dist/YoutubetoPremiere-$VERSION.pkg"
            fi
          else
            echo "Creating basic unsigned package since the first attempt failed"
            
            # Try one more time with minimal options
            pkgbuild --component "dist/YoutubetoPremiere.app" \
                   --install-location "/Applications" \
                   --identifier "com.mickael.YoutubetoPremiere" \
                   --version "$VERSION" \
                   "dist/YoutubetoPremiere-$VERSION.pkg" || {
                      ERROR_CODE=$?
                      echo "All package creation attempts failed, error code: $ERROR_CODE"
                      exit 0  # Don't fail the build
                   }
          fi
          
          # Check if final pkg was created
          if [ -f "dist/YoutubetoPremiere-$VERSION.pkg" ]; then
            echo "PKG created successfully"
            # Show package size
            PACKAGE_SIZE=$(du -h "dist/YoutubetoPremiere-$VERSION.pkg" | cut -f1)
            echo "Package size: $PACKAGE_SIZE"
            echo "PKG_CREATED=true" >> $GITHUB_ENV
          else
            echo "Failed to create PKG - file does not exist"
            ls -la dist/
          fi
          
          # Remove signature info file
          rm -f dist/signature.info
          EOF
          
          chmod +x create_macos_package.sh
        shell: bash

      - name: Create macOS Package
        if: matrix.os == 'macos-13' && env.CERTIFICATE_IMPORTED == 'true' && env.APP_PREPARED == 'true'
        env:
          VERSION: ${{ needs.check-version.outputs.version }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # Run the package creation script
          ./create_macos_package.sh "$VERSION"
          
          # Clean up script
          rm -f create_macos_package.sh
        shell: bash

      - name: Notarize and Staple macOS Package
        if: matrix.os == 'macos-13' && env.PKG_CREATED == 'true'
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          VERSION: ${{ needs.check-version.outputs.version }}
        run: |
          if [ -f "dist/YoutubetoPremiere-$VERSION.pkg" ]; then
            # Check if we have all required secrets for notarization
            if [[ -z "$APPLE_ID" || -z "$APPLE_APP_PASSWORD" || -z "$APPLE_TEAM_ID" ]]; then
              echo "Missing required secrets for notarization, skipping"
              echo "NOTARIZATION_SKIPPED=true" >> $GITHUB_ENV
              exit 0
            fi
            
            echo "Attempting to notarize the package..."
            
            # Notarize the package, but don't fail if it doesn't work
            xcrun notarytool submit "dist/YoutubetoPremiere-$VERSION.pkg" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --wait || {
                ERROR_CODE=$?
                echo "Notarization failed with error code: $ERROR_CODE"
                echo "This is expected for unsigned packages or if you don't have proper credentials"
                echo "NOTARIZATION_FAILED=true" >> $GITHUB_ENV
                exit 0  # Don't fail the build
              }
            
            # Try to staple if notarization succeeded
            if [[ "$NOTARIZATION_FAILED" != "true" ]]; then
              echo "Attempting to staple the notarization ticket..."
              xcrun stapler staple "dist/YoutubetoPremiere-$VERSION.pkg" || {
                ERROR_CODE=$?
                echo "Stapling failed with error code: $ERROR_CODE"
                echo "This is expected if notarization failed"
                exit 0  # Don't fail the build
              }
            fi
            
            # Package is ready for upload regardless of notarization status
            echo "Package is ready for upload. Notarization status may vary."
          else
            echo "Package not found, skipping notarization"
          fi
        shell: bash

      - name: Prepare Windows Installer Script
        if: matrix.os == 'windows-latest'
        env:
          VERSION: ${{ needs.check-version.outputs.version }}
        run: |
          # Create a script file for the NSIS installer setup
          New-Item -Path create_windows_installer.ps1 -ItemType File -Force
          
          # Write PowerShell script with nested here-strings
          $script = @'
          param($version)
          
          # Install NSIS
          choco install nsis -y
          
          # Create a temporary NSIS script with the version
          $nsiContent = @"
          !include "MUI2.nsh"
          !include "FileFunc.nsh"

          !define VERSION "${VERSION}"
          !define APP_NAME "YoutubetoPremiere"
          !define INSTALL_DIR "$PROGRAMFILES\YoutubetoPremiere"
          !define CEP_DIR "$APPDATA\Adobe\CEP\extensions\com.youtubetopremiere"

          ; The name of the installer
          Name "YouTube to Premiere Pro ${VERSION}"
          OutFile "YoutubetoPremiere-${VERSION}-Setup.exe"

          ; Request application privileges for Windows Vista and higher
          RequestExecutionLevel admin

          ; Set the compression algorithm 
          SetCompressor /FINAL /SOLID lzma
          SetCompressorDictSize 64

          ; The default installation directory
          InstallDir "${INSTALL_DIR}"

          ; Interface Settings
          !define MUI_ABORTWARNING

          ; Pages
          !insertmacro MUI_PAGE_WELCOME
          !insertmacro MUI_PAGE_DIRECTORY
          !insertmacro MUI_PAGE_INSTFILES
          !insertmacro MUI_PAGE_FINISH

          !insertmacro MUI_UNPAGE_CONFIRM
          !insertmacro MUI_UNPAGE_INSTFILES

          ; Languages
          !insertmacro MUI_LANGUAGE "English"

          ; The main installation section
          Section "MainSection" SEC01
            SectionIn RO
            SetOutPath "$INSTDIR"
            
            ; Create directories
            CreateDirectory "$INSTDIR\exec"
            CreateDirectory "$INSTDIR\sounds"
            CreateDirectory "${CEP_DIR}"
            
            ; Copy all files from YoutubetoPremiere directory
            File /r "dist\YoutubetoPremiere\*.*"
            
            ; Copy CEP extension files to Adobe CEP directory
            SetOutPath "${CEP_DIR}"
            File /r "dist\YoutubetoPremiere\CEP\*.*"
            
            ; Write uninstaller
            SetOutPath "$INSTDIR"
            WriteUninstaller "$INSTDIR\uninstall.exe"
            
            ; Create shortcuts
            CreateDirectory "$SMPROGRAMS\YoutubetoPremiere"
            CreateShortCut "$SMPROGRAMS\YoutubetoPremiere\YoutubetoPremiere.lnk" "$INSTDIR\exec\YoutubetoPremiere.exe"
            CreateShortCut "$SMPROGRAMS\YoutubetoPremiere\Uninstall.lnk" "$INSTDIR\uninstall.exe"
            
            ; Write registry entries for Add/Remove Programs
            WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere" "DisplayName" "YouTube to Premiere Pro"
            WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere" "UninstallString" "$\"$INSTDIR\uninstall.exe$\""
            WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere" "DisplayIcon" "$INSTDIR\exec\YoutubetoPremiere.exe"
            WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere" "DisplayVersion" "${VERSION}"
            WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere" "Publisher" "YoutubetoPremiere"
            
            ; Get the size of the install directory
            $${GetSize} "$INSTDIR" "/S=0K" $$0 $$1 $$2
            IntFmt $$0 "0x%08X" $$0
            WriteRegDWORD HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere" "EstimatedSize" "$$0"
          SectionEnd

          ; Uninstallation section
          Section "Uninstall"
            ; Remove installed files
            RMDir /r "$INSTDIR"
            RMDir /r "${CEP_DIR}"
            
            ; Remove shortcuts
            Delete "$SMPROGRAMS\YoutubetoPremiere\YoutubetoPremiere.lnk"
            Delete "$SMPROGRAMS\YoutubetoPremiere\Uninstall.lnk"
            RMDir "$SMPROGRAMS\YoutubetoPremiere"
            
            ; Remove registry entries
            DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\YoutubetoPremiere"
          SectionEnd
          "@

          # Replace version variable in the script
          $nsiContent = $nsiContent.Replace('${VERSION}', $version)

          # Save the NSIS script
          Set-Content -Path "installer_temp.nsi" -Value $nsiContent

          # Run NSIS compiler with our script
          makensis installer_temp.nsi

          # Verify installer was created
          if (!(Test-Path "YoutubetoPremiere-$version-Setup.exe")) {
            Write-Error "Failed to create installer"
            exit 1
          }

          # Create installer directory if it doesn't exist
          New-Item -Path "dist/installer" -ItemType Directory -Force -ErrorAction SilentlyContinue

          # Move installer to dist directory
          Move-Item "YoutubetoPremiere-$version-Setup.exe" "dist/installer/" -Force

          # Clean up temporary file
          Remove-Item "installer_temp.nsi" -ErrorAction SilentlyContinue

          # Show installer size
          $installerSize = (Get-Item "dist/installer/YoutubetoPremiere-$version-Setup.exe").Length
          Write-Host "Installer created successfully. Size: $($installerSize / 1MB) MB"
          '@
          
          # Write script to file
          Set-Content -Path create_windows_installer.ps1 -Value $script
        shell: pwsh

      - name: Create Windows Installer
        if: matrix.os == 'windows-latest'
        env:
          VERSION: ${{ needs.check-version.outputs.version }}
        run: |
          # Run the installer creation script
          .\create_windows_installer.ps1 -version "$env:VERSION"
          
          # Clean up script
          Remove-Item create_windows_installer.ps1 -ErrorAction SilentlyContinue
        shell: pwsh

      - name: Upload Windows executable
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: executable-windows-latest
          path: dist/YoutubetoPremiere.exe
          retention-days: 90
      
      - name: Upload macOS executable
        if: matrix.os == 'macos-13'
        uses: actions/upload-artifact@v4
        with:
          name: executable-macos-13
          path: |
            dist/bin/YoutubetoPremiere
            dist/YoutubetoPremiere.app/**/*
            dist/YoutubetoPremiere/**/*
          retention-days: 90
      
      - name: Upload Windows installer
        if: matrix.os == 'windows-latest'
        uses: actions/upload-artifact@v4
        with:
          name: installer-windows
          path: dist/installer/YoutubetoPremiere-${{ needs.check-version.outputs.version }}-Setup.exe
          retention-days: 90

      - name: Upload macOS installer
        if: matrix.os == 'macos-13' && env.PKG_CREATED == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: installer-macos
          path: dist/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.pkg
          retention-days: 90

  create-release:
    needs: [check-version, build-executables]
    if: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v') }}
    runs-on: ubuntu-latest
    steps:
      - name: Create directories for artifacts
        run: |
          mkdir -p dist/windows
          mkdir -p dist/macos
        shell: bash

      - name: Download Windows installer
        uses: actions/download-artifact@v4
        with:
          name: installer-windows
          path: dist/windows
        
      - name: Download macOS installer
        uses: actions/download-artifact@v4
        with:
          name: installer-macos
          path: dist/macos
      
      - name: List downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          ls -la dist/
          find dist -type f | sort
        shell: bash

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            dist/windows/YoutubetoPremiere-${{ needs.check-version.outputs.version }}-Setup.exe
            dist/macos/YoutubetoPremiere-${{ needs.check-version.outputs.version }}.pkg
          name: YoutubetoPremiere v${{ needs.check-version.outputs.version }}
          tag_name: v${{ needs.check-version.outputs.version }}
          generate_release_notes: true