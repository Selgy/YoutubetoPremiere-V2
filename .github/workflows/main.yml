name: Build and Package

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

permissions:
  contents: write
  actions: read

jobs:
  mac-build-apple-silicon:
    runs-on: macos-14
    needs: [windows-build]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10.11'
          architecture: 'arm64'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Sync clock
        run: sudo sntp -sS time.windows.com

      - name: Upgrade pip
        run: python -m pip install --upgrade pip setuptools wheel

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install python-dotenv

      - name: Install Node.js dependencies
        run: |
          yarn install --frozen-lockfile

      - name: Debug Secrets
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          echo "=== DEBUGGING SECRETS ==="
          echo "BUILD_CERTIFICATE_BASE64 length: ${#BUILD_CERTIFICATE_BASE64}"
          echo "P12_PASSWORD length: ${#P12_PASSWORD}"
          echo "KEYCHAIN_PASSWORD length: ${#KEYCHAIN_PASSWORD}"
          
          if [ -z "$BUILD_CERTIFICATE_BASE64" ]; then
            echo "❌ BUILD_CERTIFICATE_BASE64 is empty!"
            exit 1
          fi
          
          if [ -z "$P12_PASSWORD" ]; then
            echo "❌ P12_PASSWORD is empty!"
            exit 1
          fi
          
          if [ -z "$KEYCHAIN_PASSWORD" ]; then
            echo "❌ KEYCHAIN_PASSWORD is empty!"
            exit 1
          fi
          
          echo "✅ All required secrets are present"

      - name: Create and Configure Keychain
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE }}
          P12_PASSWORD: ${{ secrets.P12_PASSWORD }}
          INSTALLER_CERTIFICATE_BASE64: ${{ secrets.SIGN_INSTALL_CERTIFICATE }}
          P12_INSTALL_PASSWORD: ${{ secrets.P12_INSTALL_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          INSTALLER_CERTIFICATE_PATH=$RUNNER_TEMP/installer_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/SelgykeyAPP.keychain-db
          
          # import application certificate from secrets
          echo -n "$BUILD_CERTIFICATE_BASE64" | base64 --decode > $CERTIFICATE_PATH
          echo "Application certificate decoded, size: $(wc -c < $CERTIFICATE_PATH) bytes"
          
          # import installer certificate from secrets
          echo -n "$INSTALLER_CERTIFICATE_BASE64" | base64 --decode > $INSTALLER_CERTIFICATE_PATH
          echo "Installer certificate decoded, size: $(wc -c < $INSTALLER_CERTIFICATE_PATH) bytes"
          
          # create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          
          # import both certificates to keychain
          echo "Importing application certificate..."
          security import $CERTIFICATE_PATH -P "$P12_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          
          echo "Importing installer certificate..."
          security import $INSTALLER_CERTIFICATE_PATH -P "$P12_INSTALL_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          
          security list-keychain -d user -s $KEYCHAIN_PATH
          
          # List all identities in custom keychain
          echo "Listing all identities in SelgykeyAPP keychain:"
          security find-identity -p codesigning $KEYCHAIN_PATH

      - name: Download FFmpeg for macOS
        run: |
          echo "Downloading FFmpeg for macOS..."
          curl -L "https://evermeet.cx/ffmpeg/ffmpeg-6.1.zip" -o ffmpeg.zip
          unzip ffmpeg.zip
          chmod +x ffmpeg
          echo "FFmpeg downloaded and made executable"

      - name: Build Application with PyInstaller
        run: |
          pip install --upgrade pyinstaller
          pyinstaller --onedir --clean --debug=all \
          --hidden-import=engineio.async_drivers.eventlet \
          --hidden-import=engineio.async_drivers.gevent_uwsgi \
          --hidden-import=engineio.async_drivers.gevent \
          --hidden-import=engineio.async_drivers.threading \
          --hidden-import=engineio.async_drivers \
          --hidden-import=gevent \
          --hidden-import=websocket \
          --hidden-import=websockets \
          --hidden-import=wsproto \
          --hidden-import=pygame \
          --hidden-import=PIL \
          --hidden-import=flask \
          --hidden-import=flask_cors \
          --hidden-import=flask_socketio \
          --hidden-import=yt_dlp \
          --hidden-import=pymiere \
          --hidden-import=psutil \
          --hidden-import=tkinter \
          --add-data "app/sounds/notification_sound.mp3:." \
          --add-binary "ffmpeg:." \
          app/YoutubetoPremiere.py

      - name: Build CEP Extension
        run: |
          echo "Building CEP extension..."
          yarn build:cep
          echo "CEP build completed"
        env:
          ZXP_PACKAGE: false

      - name: Copy Python executable to CEP extension
        run: |
          echo "Copying Python executable to CEP extension..."
          rm -rf ./dist/cep/exec
          mkdir -p ./dist/cep/exec
          cp -R ./dist/YoutubetoPremiere/YoutubetoPremiere ./dist/cep/exec/
          cp -R ./dist/YoutubetoPremiere/_internal ./dist/cep/exec/
          echo "Python executable copied to CEP extension"

      - name: Make Executable
        run: |
          chmod +x ./dist/YoutubetoPremiere/YoutubetoPremiere

      - name: Sign the Application
        run: |
          echo "Signing the application..."
          codesign --deep --timestamp --options runtime --force --verify --verbose --sign "Developer ID Application: mickael ducatez (9H8DB46V75)" "./dist/YoutubetoPremiere"

      - name: Sign all binaries in dist
        run: |
          echo "Signing all binaries and frameworks in dist directory..."
          # Find and sign all executables and libraries
          find ./dist -type f \( -name "*.dylib" -o -name "*.so" -o -perm +111 \) -exec codesign --timestamp --options runtime --force --sign "Developer ID Application: mickael ducatez (9H8DB46V75)" {} \; 2>/dev/null || true
          
          # Sign any frameworks
          find ./dist -type d -name "*.framework" -exec codesign --deep --timestamp --options runtime --force --sign "Developer ID Application: mickael ducatez (9H8DB46V75)" {} \; 2>/dev/null || true
          
          echo "All binaries signed"

      - name: Prepare PKG structure
        run: |
          echo "Preparing PKG structure..."
          # Create proper structure for PKG
          mkdir -p ./pkg-root/YoutubetoPremiere
          mkdir -p ./pkg-root/com.selgy.youtubetopremiere
          
          # Copy Python application
          cp -R ./dist/YoutubetoPremiere/* ./pkg-root/YoutubetoPremiere/
          
          # Copy CEP extension (including hidden files like .debug)
          cp -R ./dist/cep/* ./pkg-root/com.selgy.youtubetopremiere/
          cp -R ./dist/cep/.debug ./pkg-root/com.selgy.youtubetopremiere/ 2>/dev/null || true
          
          # Verify critical files are present
          echo "Verifying PKG structure..."
          echo "Python app files:"
          ls -la ./pkg-root/YoutubetoPremiere/ | head -5
          echo "CEP extension files:"
          ls -la ./pkg-root/com.selgy.youtubetopremiere/ | head -10
          echo "Debug file present:" $(ls -la ./pkg-root/com.selgy.youtubetopremiere/.debug 2>/dev/null && echo "✅ YES" || echo "❌ NO")
          echo "Manifest present:" $(ls -la ./pkg-root/com.selgy.youtubetopremiere/CSXS/manifest.xml 2>/dev/null && echo "✅ YES" || echo "❌ NO")
          echo "Exec directory present:" $(ls -d ./pkg-root/com.selgy.youtubetopremiere/exec/ 2>/dev/null && echo "✅ YES" || echo "❌ NO")
          
          echo "PKG structure prepared"

      - name: Create PKG installer
        run: |
          echo "Creating PKG installer..."
          # Create PKG with proper macOS compatibility settings
          pkgbuild --root ./pkg-root \
            --identifier com.selgy.youtubetopremiere \
            --version 1.0 \
            --install-location /Applications \
            --scripts ./scripts \
            --min-os-version 10.15 \
            YouTubetoPremiere.pkg
          echo "PKG installer created successfully"
          
      - name: Sign PKG installer
        run: |
          echo "Signing PKG installer..."
          # Use productsign with the installer certificate
          productsign --sign "Developer ID Installer: mickael ducatez (9H8DB46V75)" YouTubetoPremiere.pkg YouTubetoPremiere-signed.pkg
          mv YouTubetoPremiere-signed.pkg YouTubetoPremiere.pkg
          echo "PKG installer signed successfully"

      - name: Notarize PKG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APP_SPECIFIC_PASSWORD: ${{ secrets.APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "Creating keychain profile for notarization..."
          xcrun notarytool store-credentials "notarytool-profile" --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM_ID" --password "$APP_SPECIFIC_PASSWORD"
          
          echo "Submitting PKG for notarization..."
          xcrun notarytool submit "YouTubetoPremiere.pkg" --keychain-profile "notarytool-profile" --wait

      - name: Upload macOS Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-build
          path: |
            YouTubetoPremiere.pkg

  windows-build:
    runs-on: windows-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10.11'

      - name: Cache Python dependencies
        uses: actions/cache@v4
        with:
          path: ~\AppData\Local\pip\Cache
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Cache FFmpeg
        id: cache-ffmpeg
        uses: actions/cache@v4
        with:
          path: ffmpeg.exe
          key: ${{ runner.os }}-ffmpeg-6.1-v1

      - name: Cache NSIS
        id: cache-nsis
        uses: actions/cache@v4
        with:
          path: C:\Program Files (x86)\NSIS
          key: ${{ runner.os }}-nsis-3.10.0-v1

      - name: Install NSIS (if not cached)
        if: steps.cache-nsis.outputs.cache-hit != 'true'
        run: |
          echo "Installing NSIS..."
          choco install nsis -y --force
          echo "NSIS installation completed"

      - name: Install NSIS nsProcess plugin
        run: |
          echo "Installing NSIS nsProcess plugin..."
          
          # Create plugin directories if they don't exist
          New-Item -ItemType Directory -Path "C:\Program Files (x86)\NSIS\Plugins\x86-unicode" -Force | Out-Null
          New-Item -ItemType Directory -Path "C:\Program Files (x86)\NSIS\Plugins\x86-ansi" -Force | Out-Null
          New-Item -ItemType Directory -Path "C:\Program Files (x86)\NSIS\Include" -Force | Out-Null
          
          # Create nsProcess plugin simulation
          $nsProcessNsh = @"
          !ifndef NSPROCESS_NSH
          !define NSPROCESS_NSH
          
          ; Simulate nsProcess plugin using Windows built-in commands
          !define nsProcess::FindProcess "!insertmacro nsProcess_FindProcess"
          !define nsProcess::KillProcess "!insertmacro nsProcess_KillProcess"
          
          !macro nsProcess_FindProcess PROCESS_NAME
            nsExec::ExecToStack 'tasklist /FI "IMAGENAME eq ${PROCESS_NAME}" /NH /FO CSV 2>nul | find /I "${PROCESS_NAME}"'
            Pop `$0  ; Exit code (0 if found, 1 if not found)
            Pop `$1  ; Output (ignored)
            ; Convert to nsProcess return codes: 0 = found, 603 = not found
            `${If} `$0 == 0
              StrCpy `$R0 0
            `${Else}
              StrCpy `$R0 603
            `${EndIf}
            Push `$R0
          !macroend
          
          !macro nsProcess_KillProcess PROCESS_NAME
            nsExec::ExecToStack 'taskkill /F /IM "${PROCESS_NAME}" 2>nul'
            Pop `$0  ; Exit code
            ; Convert to nsProcess return codes: 0 = success, 601 = error
            `${If} `$0 == 0
              StrCpy `$R0 0
            `${Else}
              StrCpy `$R0 601
            `${EndIf}
            Push `$R0
          !macroend
          
          !endif
          "@
          
          # Write the nsProcess.nsh include file
          $nsProcessNsh | Out-File -FilePath "C:\Program Files (x86)\NSIS\Include\nsProcess.nsh" -Encoding ASCII -Force
          
          echo "nsProcess plugin compatibility layer installed successfully"
        shell: powershell

      - name: Download FFmpeg (if not cached)
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          echo "Downloading FFmpeg for Windows..."
          Invoke-WebRequest -Uri "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip" -OutFile "ffmpeg.zip"
          Expand-Archive -Path "ffmpeg.zip" -DestinationPath "ffmpeg_temp" -Force
          $ffmpegExe = Get-ChildItem -Path "ffmpeg_temp" -Recurse -Filter "ffmpeg.exe" | Select-Object -First 1 -ExpandProperty FullName
          Copy-Item -Path $ffmpegExe -Destination "ffmpeg.exe" -Force
          Remove-Item "ffmpeg.zip" -Force
          Remove-Item "ffmpeg_temp" -Recurse -Force
          echo "FFmpeg downloaded and cached"
        shell: powershell

      - name: Verify FFmpeg
        run: |
          if (Test-Path "ffmpeg.exe") {
            echo "FFmpeg found: $(Get-Item ffmpeg.exe | Select-Object -ExpandProperty Length) bytes"
          } else {
            echo "ERROR: FFmpeg not found!"
            exit 1
          }
        shell: powershell

      - name: Install Python dependencies
        run: |
          echo "Installing Python dependencies..."
          python -m pip install --upgrade pip setuptools wheel
          pip install -r requirements.txt
          pip install --upgrade pyinstaller
          echo "Python dependencies and PyInstaller installed"

      - name: Install Node.js dependencies
        run: |
          echo "Installing Node.js dependencies..."
          yarn install --frozen-lockfile
          echo "Node.js dependencies installed"

      - name: Build Application with PyInstaller
        run: |
          echo "Building Windows application with PyInstaller..."
          pyinstaller --onedir --clean --debug=all --hidden-import=engineio.async_drivers.eventlet --hidden-import=engineio.async_drivers.gevent_uwsgi --hidden-import=engineio.async_drivers.gevent --hidden-import=engineio.async_drivers.threading --hidden-import=engineio.async_drivers --hidden-import=gevent --hidden-import=websocket --hidden-import=websockets --hidden-import=wsproto --hidden-import=pygame --hidden-import=PIL --hidden-import=flask --hidden-import=flask_cors --hidden-import=flask_socketio --hidden-import=yt_dlp --hidden-import=pymiere --hidden-import=psutil --hidden-import=tkinter --add-data "app/sounds/notification_sound.mp3;." --add-binary "ffmpeg.exe;." app/YoutubetoPremiere.py
          echo "PyInstaller build completed"

      - name: Build CEP Extension
        run: |
          echo "Building CEP extension..."
          yarn build:cep
          echo "CEP build completed"
          echo "Checking CEP build output:"
          if (Test-Path "./dist/cep") {
            echo "CEP directory exists:"
            Get-ChildItem "./dist/cep" -Recurse | Select-Object -First 10 | ForEach-Object { echo "  $($_.FullName)" }
          } else {
            echo "WARNING: CEP directory not found at ./dist/cep"
            echo "Contents of ./dist:"
            Get-ChildItem "./dist" | ForEach-Object { echo "  $($_.Name)" }
          }
        env:
          ZXP_PACKAGE: false
        shell: powershell

      - name: Copy Python executable to CEP extension
        run: |
          echo "Copying Python executable to CEP extension..."
          if (Test-Path "./dist/cep/exec") { Remove-Item "./dist/cep/exec" -Recurse -Force }
          New-Item -ItemType Directory -Path "./dist/cep/exec" -Force
          Copy-Item -Path "./dist/YoutubetoPremiere/*" -Destination "./dist/cep/exec/" -Recurse -Force
          echo "Python executable copied successfully"
        shell: powershell



      - name: Create Windows Installer
        run: |
          echo "Creating Windows installer..."
          # Get version from package.json for NSIS
          $version = (Get-Content package.json | ConvertFrom-Json).version
          echo "Version: $version"
          # Pass version to NSIS as a define parameter
          makensis /DVERSION=$version installer.nsi
          # Check what file was actually created
          echo "Files in current directory:"
          Get-ChildItem *.exe | ForEach-Object { echo $_.Name }
          # Rename to standard name for upload
          $sourceFile = "YoutubetoPremiere-$version-Setup.exe"
          $targetFile = "YouTubetoPremiere-Setup.exe"
          if (Test-Path $sourceFile) {
            Rename-Item $sourceFile $targetFile
            echo "Renamed $sourceFile to $targetFile"
          } else {
            echo "Warning: $sourceFile not found, checking for alternative names..."
            # Check for alternative file names
            $foundFiles = Get-ChildItem "YoutubetoPremiere*.exe"
            if ($foundFiles) {
              echo "Found files:"
              $foundFiles | ForEach-Object { echo "  $($_.Name)" }
              # Use the first found file
              $firstFile = $foundFiles[0].Name
              Rename-Item $firstFile $targetFile
              echo "Renamed $firstFile to $targetFile"
            } else {
              echo "Error: No installer files found!"
              exit 1
            }
          }
        shell: powershell

      - name: Cleanup temporary files
        run: |
          echo "Cleaning up temporary files to save space..."
          if (Test-Path "ffmpeg_temp") { Remove-Item "ffmpeg_temp" -Recurse -Force }
          if (Test-Path "build") { Remove-Item "build" -Recurse -Force }
          if (Test-Path "*.spec") { Remove-Item "*.spec" -Force }
          echo "Cleanup completed"
        shell: powershell

      - name: Upload Windows Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-build
          path: |
            YouTubetoPremiere-Setup.exe

  release:
    needs: [mac-build-apple-silicon, windows-build]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download macOS artifacts
        uses: actions/download-artifact@v4
        with:
          name: macos-build
          path: ./artifacts/macos

      - name: Download Windows artifacts
        uses: actions/download-artifact@v4
        with:
          name: windows-build
          path: ./artifacts/windows

      - name: Get tag name
        id: tag
        run: echo "TAG_NAME=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.TAG_NAME }}
          release_name: Release ${{ steps.tag.outputs.TAG_NAME }}
          draft: false
          prerelease: false

      - name: Upload macOS PKG
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/macos/YouTubetoPremiere.pkg
          asset_name: YouTubetoPremiere-macOS.pkg
          asset_content_type: application/octet-stream

      - name: Upload Windows EXE
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./artifacts/windows/YouTubetoPremiere-Setup.exe
          asset_name: YouTubetoPremiere-Windows.exe
          asset_content_type: application/octet-stream 