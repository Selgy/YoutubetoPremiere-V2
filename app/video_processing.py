import os
import subprocess
import logging
import yt_dlp  # Import yt_dlp directly
import re
from flask import jsonify
import sys
import platform
import time
import requests
from utils import (
    is_premiere_running,
    import_video_to_premiere,
    sanitize_title,
    generate_new_filename,
    play_notification_sound,
    get_default_download_path,
    get_license_key
)
import traceback
import glob
import json
import tempfile
import shutil
from yt_dlp.utils import download_range_func  # Importer la fonction correcte



def create_cookies_file(cookies_list):
    """Create a temporary cookies file from cookies list"""
    if not cookies_list:
        logging.warning("No cookies provided to create_cookies_file")
        return None
        
    try:
        # Create temp directory
        cookies_dir = os.path.join(os.environ.get('TEMP', tempfile.gettempdir()), 'YoutubetoPremiere')
        os.makedirs(cookies_dir, exist_ok=True)
        
        # Create cookies file
        cookies_file = os.path.join(cookies_dir, 'youtube_cookies.txt')
        
        logging.info(f"Creating cookies file at: {cookies_file}")
        
        with open(cookies_file, 'w', encoding='utf-8') as f:
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# Generated by YoutubetoPremiere Extension\n")
            
            written_cookies = 0
            for i, cookie in enumerate(cookies_list):
                try:
                    # Convert Chrome cookie to Netscape format
                    domain = cookie.get('domain', '.youtube.com')
                    name = cookie.get('name', '')
                    value = cookie.get('value', '')
                    path = cookie.get('path', '/')
                    expires = str(cookie.get('expirationDate', '0'))
                    secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
                    http_only = 'TRUE' if cookie.get('httpOnly', False) else 'FALSE'
                    
                    # Skip invalid cookies
                    if not name or not value:
                        logging.warning(f"Skipping invalid cookie {i}: name='{name}', value='{value}'")
                        continue
                    
                    # Clean and validate cookie data for Netscape format
                    # Remove any tab characters, newlines, or carriage returns that could break the format
                    name = str(name).replace('\t', '').replace('\n', '').replace('\r', '')
                    value = str(value).replace('\t', '').replace('\n', '').replace('\r', '')
                    domain = str(domain).replace('\t', '').replace('\n', '').replace('\r', '')
                    path = str(path).replace('\t', '').replace('\n', '').replace('\r', '')
                    
                    # Skip cookies with problematic values that could cause parsing issues
                    if not name or not value or '\t' in name or '\t' in value:
                        logging.warning(f"Skipping cookie with problematic format {i}: name='{name[:20]}...', value='{value[:20]}...'")
                        continue
                    
                    # Filter out known problematic cookies that aren't needed for YouTube auth
                    problematic_cookies = [
                        'GMAIL_AT',  # Gmail access token that often has formatting issues
                        'COMPASS',   # Google analytics cookie
                        '__utma',    # Google analytics
                        '__utmb',    # Google analytics
                        '__utmc',    # Google analytics
                        '__utmz',    # Google analytics
                        'IDE',       # DoubleClick cookie
                        'DV',        # DoubleClick verification
                        'WML',       # Gmail related
                        'GX',        # Gmail related
                        'SMSV',      # SMS verification
                        'ACCOUNT_CHOOSER',  # Account chooser
                        'UULE',      # Location cookie
                        '__Host-GMAIL_SCH_GMN',  # Gmail scheduler
                        '__Host-GMAIL_SCH_GMS',  # Gmail scheduler
                        '__Host-GMAIL_SCH_GML',  # Gmail scheduler
                        '__Host-GMAIL_SCH',      # Gmail scheduler
                        '__Host-GAPS',           # Google Account Plus Service - problematic format
                        '__Host-1PLSID',         # Problematic LSID variant
                        '__Host-3PLSID',         # Problematic LSID variant
                        '__Secure-DIVERSION_ID', # Diversion tracking
                        'LSOLH',     # Login related
                        '__Secure-ENID',  # Enhanced ID
                        'OTZ',       # One-time zone
                        'LSID',      # Login Session ID - often has complex values
                    ]
                    
                    # Also filter out all __Host-* cookies as they often have problematic formats
                    if name.startswith('__Host-'):
                        logging.debug(f"Skipping __Host- cookie: {name}")
                        continue
                    
                    # Also filter out any cookies from domains that aren't YouTube/Google core auth
                    problematic_domains = [
                        'mail.google.com',
                        'contacts.google.com', 
                        'chromewebstore.google.com',
                        'console.home.google.com',
                        'console.cloud.google.com',
                        'play.google.com',
                        'myactivity.google.com',
                        'one.google.com',
                        'tokenized.play.google.com',
                        'ogs.google.com',
                        'appsgenaiserver-pa.clients6.google.com',
                        'shell.cloud.google.com',
                        'chrome.google.com',
                        'www.google.com',
                        '.docs.google.com',
                        '.console.cloud.google.com',
                        'drive.google.com',
                        'lens.google.com',
                        'myaccount.google.com',
                    ]
                    
                    if name in problematic_cookies:
                        logging.debug(f"Skipping known problematic cookie: {name}")
                        continue
                        
                    if domain in problematic_domains:
                        logging.debug(f"Skipping cookie from problematic domain: {name} from {domain}")
                        continue
                    
                    # Additional safety check: skip cookies with paths that are service-specific
                    problematic_paths = ['/mail/', '/drive/', '/console/', '/play/', '/chrome/']
                    if any(prob_path in path for prob_path in problematic_paths):
                        logging.debug(f"Skipping cookie with service-specific path: {name} (path: {path})")
                        continue
                    
                    # Only keep cookies from core YouTube/Google domains needed for authentication
                    allowed_domains = [
                        '.youtube.com',
                        'www.youtube.com', 
                        'youtube.com',
                        'm.youtube.com',
                        '.google.com',
                        'accounts.google.com'
                    ]
                    
                    if domain not in allowed_domains:
                        logging.debug(f"Skipping cookie from non-essential domain: {name} from {domain}")
                        continue
                    
                    # Final validation: ensure the cookie value doesn't contain problematic characters
                    if len(value) < 3 or any(char in value for char in ['\n', '\r', '\0']):
                        logging.debug(f"Skipping cookie with invalid value format: {name}")
                        continue
                    
                    # Ensure expirationDate is properly formatted
                    try:
                        expires_float = float(expires) if expires and expires != '0' else 0
                        expires = str(int(expires_float)) if expires_float > 0 else '0'
                    except (ValueError, TypeError):
                        expires = '0'
                    
                    # Write in Netscape format: domain flag path secure expiration name value
                    cookie_line = f"{domain}\tTRUE\t{path}\t{secure}\t{expires}\t{name}\t{value}\n"
                    f.write(cookie_line)
                    written_cookies += 1
                    
                    # Log important cookies with their values (first few chars only for security)
                    if name in ['SAPISID', 'APISID', 'HSID', 'SSID', 'LOGIN_INFO', '__Secure-3PAPISID', '__Secure-3PSID']:
                        logging.info(f"Important cookie: {name} for domain {domain} (value: {value[:10]}...)")
                    
                    # Log all cookies for debugging
                    logging.debug(f"Cookie {i}: {name}={value[:10]}... (domain: {domain})")
                    
                except Exception as e:
                    logging.error(f"Error processing cookie {i}: {e}")
                    logging.error(f"Cookie data: {cookie}")
                    continue
        
        logging.info(f"Created cookies file with {written_cookies} cookies: {cookies_file}")
        
        # Log file size to verify it was created properly
        file_size = os.path.getsize(cookies_file)
        logging.info(f"Cookies file size: {file_size} bytes")
        
        # Validate the Netscape format by attempting to read it back
        try:
            with open(cookies_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                logging.info(f"Cookies file verification: {len(lines)} lines total")
                
                # Validate each line (skip comment lines)
                valid_lines = 0
                for i, line in enumerate(lines):
                    line = line.strip()
                    if not line or line.startswith('#'):
                        continue
                    
                    # Check if line has correct number of tab-separated fields
                    parts = line.split('\t')
                    if len(parts) != 7:
                        logging.warning(f"Invalid Netscape format on line {i+1}: {len(parts)} fields instead of 7")
                        logging.warning(f"Line content: {line[:100]}...")
                    else:
                        valid_lines += 1
                        
                        # Log first few valid cookie lines for verification
                        if valid_lines <= 3:
                            domain, flag, path, secure, expires, name, value = parts
                            logging.info(f"Line {i+1}: {name} for {domain} (value: {value[:15]}...)")
                
                logging.info(f"Validated {valid_lines} cookie lines in Netscape format")
                
                # If no valid lines, return None to trigger fallback
                if valid_lines == 0:
                    logging.error("No valid cookies found in generated file")
                    return None
                    
        except Exception as e:
            logging.error(f"Error validating cookies file: {e}")
            return None
        
        return cookies_file
        
    except Exception as e:
        logging.error(f"Error creating cookies file: {e}")
        return None

def get_youtube_cookies_file():
    """Get the path to the YouTube cookies file if it exists"""
    try:
        cookies_dir = os.path.join(os.environ.get('TEMP', tempfile.gettempdir()), 'YoutubetoPremiere')
        cookies_file = os.path.join(cookies_dir, 'youtube_cookies.txt')
        
        if os.path.exists(cookies_file) and os.path.getsize(cookies_file) > 0:
            logging.info(f"Found YouTube cookies file: {cookies_file}")
            return cookies_file
        else:
            logging.info("No YouTube cookies file found")
            return None
    except Exception as e:
        logging.error(f"Error checking for YouTube cookies file: {e}")
        return None

def try_extract_cookies_from_browser():
    """Try to extract cookies from browser using yt-dlp's built-in functionality"""
    try:
        cookies_dir = os.path.join(os.environ.get('TEMP', tempfile.gettempdir()), 'YoutubetoPremiere')
        os.makedirs(cookies_dir, exist_ok=True)
        
        browser_cookies_file = os.path.join(cookies_dir, 'youtube_browser_cookies.txt')
        
        # Try to extract cookies from Chrome first, then Edge, then Firefox
        browsers = ['chrome', 'edge', 'firefox']
        
        for browser in browsers:
            try:
                logging.info(f"Attempting to extract YouTube cookies from {browser}")
                
                # Use yt-dlp to extract cookies from browser
                ydl_opts = {
                    'cookiesfrombrowser': (browser, None, None, None),
                    'extract_flat': True,
                    'quiet': True,
                    'writesubtitles': False,
                    'writeautomaticsub': False,
                    'writedescription': False,
                    'writeinfojson': False,
                    'writethumbnail': False,
                }
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    # Test with a simple YouTube URL
                    info = ydl.extract_info('https://www.youtube.com/', download=False)
                    if info:
                        logging.info(f"Successfully extracted cookies from {browser}")
                        return (browser, None, None, None)
                        
            except Exception as e:
                logging.debug(f"Failed to extract cookies from {browser}: {e}")
                continue
        
        logging.warning("Could not extract cookies from any browser")
        return None
        
    except Exception as e:
        logging.error(f"Error in try_extract_cookies_from_browser: {e}")
        return None

def get_ffmpeg_path():
    """Get the path to ffmpeg executable"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    possible_locations = [
        os.path.dirname(script_dir),  # Parent directory
        script_dir,  # Current directory
        os.path.join(script_dir, 'ffmpeg'),  # ffmpeg subdirectory
        os.path.join(os.path.dirname(script_dir), 'ffmpeg'),  # Parent's ffmpeg subdirectory
        os.path.join(os.path.dirname(os.path.dirname(script_dir)), 'exec'),  # CEP extension exec directory
        os.environ.get('EXTENSION_ROOT', ''),  # Extension root if set
    ]
    
    # Add the current working directory and its parent
    possible_locations.extend([
        os.getcwd(),
        os.path.dirname(os.getcwd()),
        os.path.join(os.getcwd(), 'exec'),
        os.path.join(os.path.dirname(os.getcwd()), 'exec'),
    ])
    
    # Add macOS specific paths
    if sys.platform == 'darwin':
        possible_locations.extend([
            '/usr/local/bin',
            '/opt/homebrew/bin',
            '/usr/bin',
            os.path.expanduser('~/bin'),
            # Add common homebrew installation paths
            '/opt/homebrew/Cellar/ffmpeg',
            '/usr/local/Cellar/ffmpeg'
        ])
        
        # Try to find installed ffmpeg via 'which' command
        try:
            which_result = subprocess.run(['which', 'ffmpeg'], 
                                           stdout=subprocess.PIPE, 
                                           stderr=subprocess.PIPE, 
                                           text=True)
            if which_result.returncode == 0 and which_result.stdout.strip():
                possible_locations.append(os.path.dirname(which_result.stdout.strip()))
                logging.info(f"Found ffmpeg via 'which' at: {which_result.stdout.strip()}")
        except:
            pass
    
    # Filter out empty paths and remove duplicates while preserving order
    possible_locations = list(dict.fromkeys(filter(None, possible_locations)))
    
    ffmpeg_name = 'ffmpeg.exe' if sys.platform == 'win32' else 'ffmpeg'
    
    # First try direct paths
    for location in possible_locations:
        ffmpeg_path = os.path.join(location, ffmpeg_name)
        if os.path.exists(ffmpeg_path):
            logging.info(f"Found ffmpeg at: {ffmpeg_path}")
            # On Windows, use a simpler file existence check when running from Premiere
            if sys.platform == 'win32':
                file_size = os.path.getsize(ffmpeg_path)
                # If the file is large enough to be a valid ffmpeg executable, assume it works
                if file_size > 1000000:  # Typical ffmpeg.exe is several MB
                    logging.info(f"Assuming ffmpeg is valid based on file size ({file_size} bytes): {ffmpeg_path}")
                    return ffmpeg_path
                logging.warning(f"Found ffmpeg at {ffmpeg_path} but size is suspiciously small: {file_size} bytes")
                continue
                
            # On Unix-like systems, verify permissions
            if sys.platform != 'win32':
                if not os.access(ffmpeg_path, os.X_OK):
                    logging.warning(f"FFmpeg found at {ffmpeg_path} but is not executable")
                    continue
                    
            # Try to run ffmpeg -version to verify it works
            try:
                # Use shell=True on Windows to avoid handle issues
                use_shell = sys.platform == 'win32'
                cmd = [ffmpeg_path, '-version'] if not use_shell else f'"{ffmpeg_path}" -version'
                
                result = subprocess.run(
                    cmd,
                    shell=use_shell,
                    stdout=subprocess.PIPE, 
                    stderr=subprocess.PIPE,
                    timeout=5,
                    text=True
                )
                
                if result.returncode == 0:
                    logging.info(f"Verified ffmpeg is working at: {ffmpeg_path}")
                    return ffmpeg_path
                else:
                    logging.warning(f"FFmpeg found at {ffmpeg_path} but failed version check: {result.stderr}")
            except Exception as e:
                logging.warning(f"Error verifying ffmpeg at {ffmpeg_path}: {str(e)}")
                # If on Windows, return the path anyway if the file exists and is large enough
                if sys.platform == 'win32' and os.path.exists(ffmpeg_path) and os.path.getsize(ffmpeg_path) > 1000000:
                    logging.info(f"Despite verification error, using ffmpeg at: {ffmpeg_path}")
                    return ffmpeg_path
                continue
    
    # If not found in standard paths, try looking for ffmpeg in PATH
    if sys.platform == 'darwin':
        try:
            # On macOS, try running ffmpeg directly as it might be in PATH
            result = subprocess.run(['ffmpeg', '-version'], 
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE,
                                 timeout=5)
            if result.returncode == 0:
                logging.info("Found ffmpeg in PATH")
                return 'ffmpeg'  # Return just 'ffmpeg' to use PATH resolution
        except Exception as e:
            logging.warning(f"Error checking ffmpeg in PATH: {str(e)}")

    logging.error("FFmpeg not found in any of the expected locations")
    logging.error(f"Searched locations: {possible_locations}")
    return None

def check_ffmpeg(settings, socketio):
    """Check if ffmpeg is available"""
    ffmpeg_path = get_ffmpeg_path()
    if not ffmpeg_path:
        error_msg = "FFmpeg not found. Please ensure ffmpeg is properly installed."
        logging.error(error_msg)
        if socketio:
            socketio.emit('error', {'message': error_msg})
        return {'success': False, 'message': error_msg}
    
    # Store the full path in settings for later use
    if settings is not None:
        settings['ffmpeg_path'] = ffmpeg_path
    
    return {'success': True, 'path': ffmpeg_path}

def validate_license(license_key):
    if not license_key:
        return False

    # Try Gumroad validation
    try:
        gumroad_response = requests.post('https://api.gumroad.com/v2/licenses/verify', {
            'product_id': '9yYJT15dJO3wB4Z74N-EUg==',
            'license_key': license_key
        })

        if gumroad_response.ok and gumroad_response.json().get('success'):
            return True

        # Try Shopify validation
        api_token = 'eHyU10yFizUV5qUJaFS8koE1nIx2UCDFNSoPVdDRJDI7xtunUK6ZWe40vfwp'
        shopify_response = requests.post(
            f'https://app-easy-product-downloads.fr/api/get-license-key',
            params={'license_key': license_key, 'api_token': api_token}
        )

        if shopify_response.ok and shopify_response.json().get('status') == 'success':
            return True

    except Exception as e:
        logging.error(f"Error validating license: {e}")
        return False

    return False

def handle_video_url(video_url, download_type, current_download, socketio, settings, clip_start=None, clip_end=None, cookies=None, user_agent=None):
    """
    Handle video URL processing based on the download type.
    """
    try:
        # Validate and prepare environment
        ffmpeg_check_result = check_ffmpeg(settings, socketio)
        if not ffmpeg_check_result['success']:
            return {"error": ffmpeg_check_result['message']}
        
        # Get FFmpeg path
        ffmpeg_path = ffmpeg_check_result['path']
        if not ffmpeg_path:
            return {"error": "FFmpeg path not set in settings"}
            
        # Get download parameters from settings
        resolution = settings.get('resolution', '1080')
        download_mp3 = settings.get('downloadMP3', False)
        download_path = settings.get('downloadPath', '')
        
        # Validate license if required
        if download_type == 'video':
            license_valid = validate_license(settings.get('licenseKey'))
            if not license_valid:
                return {"error": "Invalid license. Please purchase a license to download videos."}
        
        # If no download path is set, use a default path
        if not download_path:
            download_path = get_default_download_path(socketio)
            if not download_path:
                return {"error": "Download path not set and could not determine default"}
        
        logging.info(f"Processing {download_type} request for {video_url}")
        logging.info(f"Settings: resolution={resolution}, download_path={download_path}, download_mp3={download_mp3}")
        
        if download_type == 'audio':
            # Process audio download
            result = download_audio(
                video_url=video_url, 
                download_path=download_path,
                ffmpeg_path=ffmpeg_path,
                socketio=socketio,
                current_download=current_download,
                settings=settings,
                cookies=cookies,
                user_agent=user_agent
            )
            
            if result and os.path.exists(result):
                socketio.emit('import_video', {'path': result})
                return {"success": True, "path": result}
            else:
                return {"error": "Failed to download audio"}
                
        elif download_type == 'clip':
            # Validate clip parameters
            if clip_start is None or clip_end is None:
                return {"error": "Clip start and end times must be provided"}
                
            if clip_start >= clip_end:
                return {"error": "Clip start time must be less than end time"}
            
            # Process clip download
            result = download_and_process_clip(
                video_url=video_url,
                resolution=resolution,
                download_path=download_path,
                clip_start=clip_start,
                clip_end=clip_end,
                download_mp3=download_mp3,
                ffmpeg_path=ffmpeg_path,
                socketio=socketio,
                settings=settings,
                current_download=current_download,
                cookies=cookies,
                user_agent=user_agent
            )
            
            if result and result.get("success") and result.get("path") and os.path.exists(result["path"]):
                socketio.emit('import_video', {'path': result["path"]})
                return {"success": True, "path": result["path"]}
            else:
                error_msg = result.get("error") if result and "error" in result else "Failed to download clip"
                return {"error": error_msg}
        else:
            # Process regular video download (default case)
            result = download_video(
                video_url=video_url,
                resolution=resolution,
                download_path=download_path,
                download_mp3=download_mp3,
                ffmpeg_path=ffmpeg_path,
                socketio=socketio,
                settings=settings,
                current_download=current_download,
                cookies=cookies,
                user_agent=user_agent
            )
            
            if result and os.path.exists(result):
                socketio.emit('import_video', {'path': result})
                return {"success": True, "path": result}
            else:
                return {"error": "Failed to download video"}
                
    except Exception as e:
        error_message = f"Error processing URL: {str(e)}"
        context = {
            'video_url': video_url,
            'download_type': download_type,
            'settings': {k: v for k, v in settings.items() if k not in ['licenseKey']},  # Exclude sensitive data
            'clip_start': clip_start,
            'clip_end': clip_end
        }
        write_error_log(error_message, context)
        logging.error(error_message)
        return {"error": error_message}

def sanitize_resolution(resolution):
    """Convert resolution string to a clean integer value"""
    if isinstance(resolution, int):
        return resolution
    
    # Strip 'p' suffix if present
    if isinstance(resolution, str):
        resolution = resolution.lower().replace('p', '').strip()
    
    # Convert to integer
    try:
        return int(resolution)
    except (ValueError, TypeError):
        # Default to 1080 if conversion fails
        return 1080

def download_and_process_clip(video_url, resolution, download_path, clip_start, clip_end, download_mp3, ffmpeg_path, socketio, settings, current_download, cookies=None, user_agent=None):
    clip_duration = clip_end - clip_start
    logging.info(f"Received clip parameters: clip_start={clip_start}, clip_end={clip_end}, clip_duration={clip_duration}")

    # Check if download path exists or try to get default path
    if not download_path:
        download_path = get_default_download_path(socketio)
        if not download_path:
            error_msg = "Could not determine download path. Please open a Premiere Pro project."
            logging.error(error_msg)
            socketio.emit('download-failed', {'message': error_msg})
            return {"error": error_msg}
            
    logging.info(f"Using download path: {download_path}")

    # Ensure the path exists
    try:
        os.makedirs(download_path, exist_ok=True)
        logging.info(f"Ensured download directory exists: {download_path}")
    except Exception as e:
        error_msg = f"Could not create download directory: {str(e)}"
        logging.error(error_msg)
        socketio.emit('download-failed', {'message': error_msg})
        return {"error": error_msg}

    try:
        # Ensure ffmpeg path is valid
        if not ffmpeg_path:
            logging.error("FFmpeg path not provided")
            socketio.emit('download-failed', {'message': 'FFmpeg not found. Please check settings.'})
            return {"error": "FFmpeg not found at specified path"}
            
        # Emit initial status message to user
        socketio.emit('percentage', {'percentage': f"Clip: {format_timestamp(clip_start)} à {format_timestamp(clip_end)}"})
                
        # Handle cancellation
        is_cancelled = [False]
        def cancel_callback():
            is_cancelled[0] = True
            return is_cancelled[0]
        
        current_download['cancel_callback'] = cancel_callback
                
        # Get sanitized title for the output file
        sanitized_title = ''
        try:
            with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
                video_info = ydl.extract_info(video_url, download=False)
                if video_info:
                    sanitized_title = sanitize_youtube_title(video_info.get('title', 'video'))
                else:
                    sanitized_title = 'clip_' + str(int(time.time()))
        except Exception as e:
            logging.error(f"Error extracting video info: {str(e)}")
            sanitized_title = 'clip_' + str(int(time.time()))
            
        # Get unique filename
        unique_filename = get_unique_filename(download_path, sanitized_title + '_clip', 'mp4')
        video_file_path = os.path.join(download_path, unique_filename)
        logging.info(f"Setting output path to: {video_file_path}")

        # Get preferred audio language from settings
        preferred_language = settings.get('preferredAudioLanguage', 'original')
        logging.info(f"Using preferred audio language for clip: {preferred_language}")
        
        # Format string for the desired quality - FORCE AVC1 CODEC with language preference
        sanitized_resolution = sanitize_resolution(resolution)
        if preferred_language != 'original':
            format_str = f'bestvideo[height<={sanitized_resolution}][vcodec^=avc1][ext=mp4]+bestaudio[ext=m4a][language~="{preferred_language}"]/bestvideo[height<={sanitized_resolution}][vcodec^=avc1][ext=mp4]+bestaudio[ext=m4a]/best[vcodec^=avc1][ext=mp4]/best'
        else:
            format_str = f'bestvideo[height<={sanitized_resolution}][vcodec^=avc1][ext=mp4]+bestaudio[ext=m4a]/best[vcodec^=avc1][ext=mp4]/best'
        logging.info(f"Using format string with AVC1 codec and language preference: {format_str}")
        
        # CORRECTION: Utiliser download_ranges au lieu de download_sections
        logging.info(f"Using download ranges: start={clip_start}, end={clip_end}")
        
        # Progress hook to track download progress and send updates
        def progress_hook(d):
            if is_cancelled[0]:
                # This will be checked in the postprocessor hook
                return
                
            if d['status'] == 'downloading':
                try:
                    if '_percent_str' in d:
                        percentage = d['_percent_str'].strip()
                        percentage = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', percentage)
                        percentage = percentage.replace(' ', '').replace('%', '')
                        logging.info(f'Clip Progress: {percentage}%')
                        socketio.emit('progress', {'progress': percentage, 'type': 'clip'})
                except Exception as e:
                    logging.error(f"Error in clip progress hook: {e}")

        # Configure yt-dlp options avec download_ranges - CORRECTION IMPORTANTE
        ydl_opts = {
            'format': format_str,
            'outtmpl': video_file_path,
            # For Windows, use the absolute path to ffmpeg executable instead of just the directory
            'ffmpeg_location': ffmpeg_path if sys.platform == 'win32' else os.path.dirname(ffmpeg_path) if os.path.dirname(ffmpeg_path) else '.',
            'force_keyframes_at_cuts': True,
            'download_ranges': download_range_func(None, [(clip_start, clip_end)]),  # Utiliser la fonction correcte
            'no_part': True,
            'progress_hooks': [progress_hook],
            'verbose': True,  # Enable verbose output for debugging
            'nocheckcertificate': True,  # Skip certificate validation which can fail in some environments
            'ignoreerrors': True,  # Continue downloading even if some errors occur
            'geo_bypass': True,  # Bypass geographic restrictions
            'geo_bypass_country': 'US',  # Use US as bypass country
            'age_limit': None,  # Don't apply age limits
            'extractor_retries': 5,  # Retry extraction up to 5 times
            'retry_sleep': lambda n: 5 * (n + 1),  # Exponential backoff
            'postprocessor_args': ['-threads', '4'],  # Limit threads to avoid resource issues
            # Explicitly set the ffmpeg executable to use
            'external_downloader_args': ['-timeout', '60']  # Add timeout to prevent hanging
        }
        
        # Check for manual cookies file first (more reliable for age-restricted content)
        manual_cookies_file = get_youtube_cookies_file()
        
        if manual_cookies_file and os.path.exists(manual_cookies_file):
            ydl_opts['cookiefile'] = manual_cookies_file
            logging.info(f"Using manual cookies file for clip download: {manual_cookies_file}")
        elif cookies:
            # Fallback to automatic cookies from extension
            cookies_file = create_cookies_file(cookies)
            if cookies_file:
                ydl_opts['cookiefile'] = cookies_file
                logging.info(f"Using automatic cookies from extension for clip download: {len(cookies)} cookies")
            else:
                logging.warning("Failed to create cookies file from extension data")
        else:
            # Last resort: try to extract cookies from browser
            browser_cookies = try_extract_cookies_from_browser()
            if browser_cookies:
                ydl_opts['cookiesfrombrowser'] = browser_cookies
                logging.info(f"Using cookies from browser for clip download: {browser_cookies[0]}")
            else:
                logging.warning("No cookies available for YouTube authentication")
        
        # Add user agent if provided
        if user_agent:
            ydl_opts['http_headers'] = {'User-Agent': user_agent}
            logging.info("Using User-Agent from extension for clip download")
        
        logging.info(f"Download options: {ydl_opts}")
        
        # Download with yt-dlp
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                current_download['ydl'] = ydl
                
                # Log the environment variables related to ffmpeg
                logging.info(f"Environment PATH: {os.environ.get('PATH')}")
                logging.info(f"Environment FFMPEG_PATH: {os.environ.get('FFMPEG_PATH')}")
                
                # Verify ffmpeg actually exists at the path
                if not os.path.exists(ffmpeg_path):
                    logging.error(f"FFmpeg executable not found at configured path: {ffmpeg_path}")
                    socketio.emit('download-failed', {'message': f"FFmpeg executable not found at: {ffmpeg_path}"})
                    return {"error": f"FFmpeg executable not found at: {ffmpeg_path}"}
                
                logging.info(f"Starting clip download for {video_url} using ffmpeg at {ffmpeg_path}")
                ydl.download([video_url])
                
                # Check if the download was canceled
                if is_cancelled[0]:
                    if os.path.exists(video_file_path):
                        os.remove(video_file_path)
                    return {"error": "Download cancelled by user"}
                    
            except Exception as e:
                error_message = f"Error downloading clip: {str(e)}"
                logging.error(error_message)
                logging.error(f"Exception type: {type(e).__name__}")
                logging.error(f"Exception traceback: {traceback.format_exc()}")
                
                # Check if error is related to ffmpeg
                error_str = str(e).lower()
                if 'ffmpeg' in error_str or 'executable' in error_str:
                    logging.error(f"FFmpeg-related error detected. Current ffmpeg path: {ffmpeg_path}")
                    # Suggest potential solutions
                    solutions = "Try restarting the application or using a different clip download approach."
                    error_message += f" This appears to be related to ffmpeg. {solutions}"
                
                socketio.emit('download-failed', {'message': error_message})
                return {"error": error_message}
            finally:
                current_download['ydl'] = None
                current_download['cancel_callback'] = None

        # Add metadata to the video file if it exists
        if os.path.exists(video_file_path):
            logging.info(f"Clip downloaded successfully: {video_file_path}")

            # Add URL to metadata
            use_shell = sys.platform == 'Windows'
            if use_shell:
                # For Windows, build a shell command with quoted paths
                metadata_command = f'"{ffmpeg_path}" -i "{video_file_path}" -metadata comment="{video_url}" -metadata clip_start="{clip_start}" -metadata clip_end="{clip_end}" -codec copy "{video_file_path}_with_metadata.mp4"'
            else:
                # For macOS/Linux, use array format
                metadata_command = [
                    ffmpeg_path,
                    '-i', video_file_path,
                    '-metadata', f'comment={video_url}',
                    '-metadata', f'clip_start={clip_start}',
                    '-metadata', f'clip_end={clip_end}',
                    '-codec', 'copy',
                    f'{video_file_path}_with_metadata.mp4'
                ]

            try:
                subprocess.run(metadata_command, check=True, capture_output=True, text=True, shell=use_shell)
                os.replace(f'{video_file_path}_with_metadata.mp4', video_file_path)
                logging.info(f"Metadata added: {video_file_path}")
                
                # Emit events
                socketio.emit('complete', {'type': 'clip', 'message': 'Clip téléchargé avec succès'})
                socketio.emit('download-complete', {'url': video_url, 'path': video_file_path})
                socketio.emit('download_complete')
                return {"success": True, "path": video_file_path}
            except subprocess.CalledProcessError as e:
                logging.error(f"Error adding metadata: {e.stderr}")
                # Continue anyway, as the clip itself is fine
                socketio.emit('download-complete', {'url': video_url, 'path': video_file_path})
                socketio.emit('download_complete')
                return {"success": True, "path": video_file_path}
        else:
            error_message = "Clip download failed - output file not found"
            logging.error(error_message)
            socketio.emit('download-failed', {'message': error_message})
            return {"error": error_message}

    except Exception as e:
        error_message = f"Error downloading clip: {str(e)}"
        logging.error(error_message)
        logging.error(f"Full error details: {type(e).__name__}")
        socketio.emit('download-failed', {'message': error_message})
        return {"error": error_message}

def sanitize_youtube_title(title):
    # Remove invalid filename characters and strip excess whitespace
    sanitized_title = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', title).strip()
    # Replace problematic characters with underscores
    sanitized_title = re.sub(r'\s+', '_', sanitized_title)
    return sanitized_title

def get_unique_filename(base_path, filename, extension):
    """
    Generate a unique filename by adding incremental numbers if the file already exists.
    Example: if 'video.mp4' exists, try 'video_1.mp4', 'video_2.mp4', etc.
    """
    if not os.path.exists(os.path.join(base_path, f"{filename}.{extension}")):
        return f"{filename}.{extension}"
    
    counter = 1
    while os.path.exists(os.path.join(base_path, f"{filename}_{counter}.{extension}")):
        counter += 1
    
    return f"{filename}_{counter}.{extension}"

def download_video(video_url, resolution, download_path, download_mp3, ffmpeg_path, socketio, settings, current_download, cookies=None, user_agent=None):
    check_result = check_ffmpeg(settings, socketio)
    if not check_result['success']:
        return None

    try:
        import yt_dlp

        def progress_hook(d):
            if d['status'] == 'downloading':
                try:
                    if '_percent_str' in d:
                        percentage = d['_percent_str'].strip()
                        percentage = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', percentage)
                        percentage = percentage.replace(' ', '').replace('%', '')
                        logging.info(f'Progress: {percentage}%')
                        socketio.emit('progress', {'progress': percentage, 'type': 'full'})
                except Exception as e:
                    logging.error(f"Error in progress hook: {e}")

        # Get preferred audio language from settings
        preferred_language = settings.get('preferredAudioLanguage', 'original')
        logging.info(f"Using preferred audio language: {preferred_language}")
        
        # Configure yt-dlp options with AVC1 codec and audio language preference
        if preferred_language != 'original':
            # Use language-specific format selector
            format_string = f'bestvideo[vcodec^=avc1][height<={int(resolution.replace("p", ""))}][ext=mp4]+bestaudio[ext=m4a][language~="{preferred_language}"]/bestvideo[vcodec^=avc1][height<={int(resolution.replace("p", ""))}][ext=mp4]+bestaudio[ext=m4a]/best[vcodec^=avc1][ext=mp4]/best[ext=mp4]'
        else:
            format_string = f'bestvideo[vcodec^=avc1][height<={int(resolution.replace("p", ""))}][ext=mp4]+bestaudio[ext=m4a]/best[vcodec^=avc1][ext=mp4]/best[ext=mp4]'
        
        logging.info(f"Using format string with AVC1 codec and language preference: {format_string}")

        # Check if download path exists or try to get default path
        if not download_path:
            download_path = get_default_download_path(socketio)
            if not download_path:
                error_msg = "Could not determine download path. Please open a Premiere Pro project."
                logging.error(error_msg)
                socketio.emit('download-failed', {'message': error_msg})
                return None
            
        logging.info(f"Using download path: {download_path}")

        # Ensure the path exists
        try:
            os.makedirs(download_path, exist_ok=True)
            logging.info(f"Ensured download directory exists: {download_path}")
        except Exception as e:
            error_msg = f"Could not create download directory: {str(e)}"
            logging.error(error_msg)
            socketio.emit('download-failed', {'message': error_msg})
            return None

        # Configure initial yt-dlp options with authentication
        initial_ydl_opts = {
            'quiet': True,
            'no_warnings': False,  # Enable warnings to see what's happening
            'age_limit': None,  # Don't apply age limits
            'skip_download': True,  # Only extract info
            'geo_bypass': True,  # Bypass geographic restrictions
            'geo_bypass_country': 'US',  # Use US as bypass country
            'nocheckcertificate': True,  # Skip certificate validation
            'extractor_retries': 5,  # Retry extraction up to 5 times
            'retry_sleep': lambda n: 5 * (n + 1),  # Exponential backoff
        }
        
        # Check for manual cookies file first (more reliable for age-restricted content)
        manual_cookies_file = get_youtube_cookies_file()
        
        if manual_cookies_file and os.path.exists(manual_cookies_file):
            initial_ydl_opts['cookiefile'] = manual_cookies_file
            logging.info(f"Using manual cookies file for info extraction: {manual_cookies_file}")
        elif cookies:
            # Fallback to automatic cookies from extension
            cookies_file = create_cookies_file(cookies)
            if cookies_file:
                initial_ydl_opts['cookiefile'] = cookies_file
                logging.info(f"Using automatic cookies from extension for info extraction: {len(cookies)} cookies")
            else:
                logging.warning("Failed to create cookies file from extension data")
        else:
            # Last resort: try to extract cookies from browser
            browser_cookies = try_extract_cookies_from_browser()
            if browser_cookies:
                initial_ydl_opts['cookiesfrombrowser'] = browser_cookies
                logging.info(f"Using cookies from browser for info extraction: {browser_cookies[0]}")
            else:
                logging.warning("No cookies available for YouTube authentication")
        
        # Add user agent if provided for info extraction
        if user_agent:
            initial_ydl_opts['http_headers'] = {'User-Agent': user_agent}
            logging.info("Using User-Agent from extension for info extraction")
        
        # Extract video info first with authentication
        with yt_dlp.YoutubeDL(initial_ydl_opts) as ydl:
            info = ydl.extract_info(video_url, download=False)
            if not info:
                raise Exception("Could not extract video information")
            
            # Check if any video formats are available
            video_formats = [f for f in info.get('formats', []) if f.get('vcodec') != 'none' and f.get('acodec') != 'none']
            if not video_formats:
                error_msg = "This URL contains only images or is not a valid video. Please provide a URL to a video."
                logging.error(error_msg)
                socketio.emit('download-failed', {'message': error_msg})
                return None

            # Get video details
            title = info.get('title', 'video')
            
            # Sanitize the title
            sanitized_title = sanitize_youtube_title(title)
            logging.info(f"Sanitized title: {sanitized_title}")
            
            # Get unique filename
            unique_filename = get_unique_filename(download_path, sanitized_title, 'mp4')
            output_path = os.path.join(download_path, unique_filename)
            logging.info(f"Setting output path to: {output_path}")

            # Configure download options
            ydl_opts = {
                'format': format_string,
                'merge_output_format': 'mp4',
                # For Windows, use the absolute path to ffmpeg executable instead of just the directory
                'ffmpeg_location': ffmpeg_path if sys.platform == 'win32' else os.path.dirname(ffmpeg_path),
                'progress_hooks': [progress_hook],
                'postprocessor_hooks': [lambda d: socketio.emit('progress', {'progress': '100', 'type': 'full'}) if d['status'] == 'finished' else None],
                'verbose': True,
                'nocheckcertificate': True,  # Skip certificate validation which can fail in some environments
                'ignoreerrors': True,  # Continue downloading even if some errors occur
                'postprocessor_args': ['-threads', '4'],  # Limit threads to avoid resource issues
                'external_downloader_args': ['-timeout', '60'],  # Add timeout to prevent hanging
                'geo_bypass': True,  # Bypass geographic restrictions
                'geo_bypass_country': 'US',  # Use US as bypass country
                'extractor_retries': 5,  # Retry extraction up to 5 times
                'retry_sleep': lambda n: 5 * (n + 1),  # Exponential backoff
                'age_limit': None,  # Don't apply age limits
                'outtmpl': {
                    'default': os.path.join(download_path, os.path.splitext(unique_filename)[0] + '.%(ext)s')
                }
            }
            
            # Check for manual cookies file first (more reliable for age-restricted content)
            if manual_cookies_file and os.path.exists(manual_cookies_file):
                ydl_opts['cookiefile'] = manual_cookies_file
                logging.info(f"Using manual cookies file for download: {manual_cookies_file}")
            elif cookies:
                # Fallback to automatic cookies from extension
                cookies_file = create_cookies_file(cookies)
                if cookies_file:
                    ydl_opts['cookiefile'] = cookies_file
                    logging.info(f"Using automatic cookies from extension for download: {len(cookies)} cookies")
                else:
                    logging.warning("Failed to create cookies file from extension data")
            else:
                # Last resort: try to extract cookies from browser
                browser_cookies = try_extract_cookies_from_browser()
                if browser_cookies:
                    ydl_opts['cookiesfrombrowser'] = browser_cookies
                    logging.info(f"Using cookies from browser for download: {browser_cookies[0]}")
                else:
                    logging.warning("No cookies available for YouTube authentication")
            
            # Add user agent if provided
            if user_agent:
                ydl_opts['http_headers'] = {'User-Agent': user_agent}
                logging.info("Using User-Agent from extension for download")

            # Download the video
            logging.info("Starting video download...")
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                ydl.process_ie_result(info, download=True)

            # Get the final path of the downloaded file
            final_path = output_path
            logging.info(f"Expected final path: {final_path}")

            if os.path.exists(final_path):
                logging.info(f"File exists at: {final_path}")
                # Add URL to metadata
                metadata_command = [
                    ffmpeg_path,  # Use the full path here
                    '-i', final_path,
                    '-metadata', f'comment={video_url}',
                    '-codec', 'copy',
                    f'{final_path}_with_metadata.mp4'
                ]
                logging.info(f"Running FFmpeg command: {' '.join(metadata_command)}")

                try:
                    subprocess.run(metadata_command, check=True)
                    os.replace(f'{final_path}_with_metadata.mp4', final_path)
                    
                    logging.info(f"Video downloaded and processed: {final_path}")
                    socketio.emit('import_video', {'path': final_path})
                    # Emit both formats to ensure compatibility
                    socketio.emit('download-complete', {'url': video_url, 'path': final_path})  # Hyphenated format for Chrome extension
                    socketio.emit('download_complete')  # Underscore format for other clients
                    
                    return final_path
                except subprocess.CalledProcessError as e:
                    logging.error(f"Error adding metadata: {e}")
                    logging.error(f"FFmpeg stderr: {e.stderr if hasattr(e, 'stderr') else 'No stderr'}")
                    socketio.emit('download-failed', {'message': 'Failed to add metadata.'})
                    return None
            else:
                logging.error(f"File not found at expected path: {final_path}")
                raise Exception(f"Downloaded file not found at {final_path}")

    except Exception as e:
        error_message = f"Error downloading video: {str(e)}"
        logging.error(error_message)
        logging.error(f"Exception type: {type(e)}")
        logging.error(f"Exception traceback: {traceback.format_exc()}")
        socketio.emit('download-failed', {'message': error_message})
        return None

def download_audio(video_url, download_path, ffmpeg_path, socketio, current_download=None, settings=None, cookies=None, user_agent=None):
    check_result = check_ffmpeg(None, socketio)
    if not check_result['success']:
        return None

    try:
                        # Emit initial status        socketio.emit('progress', {'progress': '0', 'type': 'audio'})
        
        # Check if download path exists or try to get default path
        if not download_path:
            download_path = get_default_download_path(socketio)
            if not download_path:
                error_msg = "Could not determine download path. Please open a Premiere Pro project."
                logging.error(error_msg)
                socketio.emit('download-failed', {'message': error_msg})
                return None
                
        logging.info(f"Using download path for audio: {download_path}")
        
        # Ensure the path exists
        try:
            os.makedirs(download_path, exist_ok=True)
            logging.info(f"Ensured download directory exists: {download_path}")
        except Exception as e:
            error_msg = f"Could not create download directory: {str(e)}"
            logging.error(error_msg)
            socketio.emit('download-failed', {'message': error_msg})
            return None

        # Get preferred audio language from settings
        preferred_language = 'original'
        if settings:
            preferred_language = settings.get('preferredAudioLanguage', 'original')
        logging.info(f"Using preferred audio language for audio download: {preferred_language}")
        
        # Configure format selector based on language preference
        if preferred_language != 'original':
            audio_format = f'bestaudio[language~="{preferred_language}"]/bestaudio/best'
        else:
            audio_format = 'bestaudio/best'
        
        # Define progress hook function
        def progress_hook(d):
            if d['status'] == 'downloading':
                try:
                    if '_percent_str' in d:
                        percentage = d['_percent_str'].strip()
                        percentage = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', percentage)
                        percentage = percentage.replace(' ', '').replace('%', '')
                        logging.info(f'Progress: {percentage}%')
                        socketio.emit('progress', {'progress': percentage, 'type': 'audio'})
                except Exception as e:
                    logging.error(f"Error in progress hook: {e}")
            elif d['status'] == 'finished':
                socketio.emit('progress', {'progress': '100', 'type': 'audio'})

        # Configure yt-dlp options with retries and timeouts
        ydl_opts = {
            'format': audio_format,
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'wav',
            }],
            # For Windows, use the absolute path to ffmpeg executable instead of just the directory
            'ffmpeg_location': ffmpeg_path if sys.platform == 'win32' else os.path.dirname(ffmpeg_path),
            'progress_hooks': [progress_hook],
            'retries': 10,  # Retry up to 10 times
            'fragment_retries': 10,
            'retry_sleep': lambda n: 5 * (n + 1),  # Exponential backoff
            'socket_timeout': 30,
            'extractor_retries': 5,
            'file_access_retries': 5,  # Retry file access operations
            'nocheckcertificate': True,  # Skip certificate validation which can fail in some environments
            'ignoreerrors': True,  # Continue downloading even if some errors occur
            'geo_bypass': True,  # Bypass geographic restrictions
            'geo_bypass_country': 'US',  # Use US as bypass country
            'age_limit': None,  # Don't apply age limits
            'postprocessor_args': [
                '-metadata', f'comment={video_url}',
                '-y',  # Overwrite output files
                '-threads', '4'  # Limit threads to avoid resource issues
            ],
            'external_downloader_args': ['-timeout', '60']  # Add timeout to prevent hanging
        }
        
        # Check for manual cookies file first (more reliable for age-restricted content)
        manual_cookies_file = get_youtube_cookies_file()
        
        if manual_cookies_file and os.path.exists(manual_cookies_file):
            ydl_opts['cookiefile'] = manual_cookies_file
            logging.info(f"Using manual cookies file for audio download: {manual_cookies_file}")
        elif cookies:
            # Fallback to automatic cookies from extension
            cookies_file = create_cookies_file(cookies)
            if cookies_file:
                ydl_opts['cookiefile'] = cookies_file
                logging.info(f"Using automatic cookies from extension for audio download: {len(cookies)} cookies")
            else:
                logging.warning("Failed to create cookies file from extension data")
        else:
            # Last resort: try to extract cookies from browser
            browser_cookies = try_extract_cookies_from_browser()
            if browser_cookies:
                ydl_opts['cookiesfrombrowser'] = browser_cookies
                logging.info(f"Using cookies from browser for audio download: {browser_cookies[0]}")
            else:
                logging.warning("No cookies available for YouTube authentication")
        
        # Add user agent if provided
        if user_agent:
            ydl_opts['http_headers'] = {'User-Agent': user_agent}
            logging.info("Using User-Agent from extension for audio download")

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                # Extract info first to verify URL is valid and get title
                info = ydl.extract_info(video_url, download=False)
                if not info:
                    raise Exception("Could not extract video information")

                # Create unique filename
                title = info.get('title', 'audio')
                sanitized_title = sanitize_youtube_title(title)
                output_path = os.path.join(download_path, f"{sanitized_title}.wav")

                # Ensure directory exists
                os.makedirs(download_path, exist_ok=True)

                # Remove existing temp files if any
                temp_pattern = os.path.join(download_path, f"temp_{sanitized_title}*")
                for temp_file in glob.glob(temp_pattern):
                    try:
                        os.remove(temp_file)
                    except:
                        pass

                # Set output template after getting info
                ydl_opts['outtmpl'] = os.path.join(download_path, f'temp_{sanitized_title}')
                
                # Create new YoutubeDL instance with updated options
                with yt_dlp.YoutubeDL(ydl_opts) as ydl_download:
                    # Download using the already extracted info
                    ydl_download.process_ie_result(info, download=True)

                # Find the downloaded file
                downloaded_file = None
                for file in os.listdir(download_path):
                    if file.startswith('temp_') and file.endswith('.wav'):
                        downloaded_file = os.path.join(download_path, file)
                        break

                if not downloaded_file:
                    raise Exception("Could not find downloaded audio file")

                # Add metadata using ffmpeg
                temp_output = output_path + "_with_metadata.wav"
                metadata_cmd = [
                    ffmpeg_path,
                    '-i', downloaded_file,
                    '-metadata', f'comment={video_url}',
                    '-y',
                    temp_output
                ]

                subprocess.run(metadata_cmd, check=True)

                # Clean up and rename
                try:
                    os.remove(downloaded_file)
                except:
                    pass

                try:
                    os.rename(temp_output, output_path)
                except:
                    # If rename fails, try copy and delete
                    import shutil
                    shutil.copy2(temp_output, output_path)
                    try:
                        os.remove(temp_output)
                    except:
                        pass

                # Emit both completion events before returning
                if socketio:
                    socketio.emit('import_video', {'path': output_path})
                    # Emit both formats to ensure compatibility
                    socketio.emit('download-complete', {'url': video_url, 'path': output_path})  # Hyphenated format for Chrome extension
                    socketio.emit('download_complete')  # Underscore format for other clients

                return output_path

            except Exception as e:
                logging.error(f"Error downloading audio: {str(e)}")
                logging.error(f"Exception type: {type(e)}")
                logging.error(f"Exception traceback: {traceback.format_exc()}")
                if socketio:
                    socketio.emit('download-failed', {'message': f'Error downloading audio: {str(e)}'})
                return None

    except Exception as e:
        logging.error(f"Error in download_audio: {str(e)}")
        if socketio:
            socketio.emit('download-failed', {'message': str(e)})
        return None

def format_timestamp(seconds):
    """Convert seconds to HH:MM:SS format"""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    seconds = seconds % 60
    return f"{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d}"

def get_audio_format_selector(preferred_language='original'):
    """
    Create a format selector string for yt-dlp that prefers a specific audio language
    with fallback to original audio if the preferred language is not available.
    """
    if preferred_language == 'original':
        # Return the original best format selector
        return 'bestvideo+bestaudio/best'
    
    # Language mapping for common cases
    language_codes = {
        'en': ['en', 'eng', 'english'],
        'fr': ['fr', 'fre', 'fra', 'french', 'français'],
        'es': ['es', 'spa', 'spanish', 'español'],
        'de': ['de', 'ger', 'deu', 'german', 'deutsch'],
        'it': ['it', 'ita', 'italian', 'italiano'],
        'pt': ['pt', 'por', 'portuguese', 'português'],
        'ru': ['ru', 'rus', 'russian', 'русский'],
        'ja': ['ja', 'jpn', 'japanese', '日本語'],
        'ko': ['ko', 'kor', 'korean', '한국어'],
        'zh': ['zh', 'chi', 'zho', 'chinese', '中文'],
        'ar': ['ar', 'ara', 'arabic', 'العربية'],
        'hi': ['hi', 'hin', 'hindi', 'हिन्दी']
    }
    
    # Get all possible language codes for the preferred language
    lang_variants = language_codes.get(preferred_language, [preferred_language])
    
    # Create format selector that prefers the specified language
    # Format: try language-specific audio + best video, fallback to original best
    lang_conditions = '|'.join(lang_variants)
    format_selector = f'bestvideo+bestaudio[language~="{lang_conditions}"]/bestvideo+bestaudio/best'
    
    return format_selector

def get_audio_language_options(video_url):
    """
    Extract available audio language options from a YouTube video.
    Returns a list of available languages.
    """
    try:
        with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
            info = ydl.extract_info(video_url, download=False)
            if not info:
                return []
            
            available_languages = set()
            formats = info.get('formats', [])
            
            for fmt in formats:
                if fmt.get('acodec') != 'none':  # Audio format
                    lang = fmt.get('language')
                    if lang:
                        available_languages.add(lang)
            
            return sorted(list(available_languages))
    except Exception as e:
        logging.error(f"Error extracting audio languages: {str(e)}")
        return []

def write_error_log(error_message, context=None):
    """Write error to dedicated error log file"""
    try:
        log_dir = os.environ.get('YTPP_LOG_DIR')
        if not log_dir:
            return
        
        error_log_path = os.path.join(log_dir, 'video_processing_errors.log')
        
        from datetime import datetime
        timestamp = datetime.now().isoformat()
        
        with open(error_log_path, 'a', encoding='utf-8') as f:
            f.write(f"\n[{timestamp}] ERROR: {error_message}\n")
            if context:
                f.write(f"Context: {json.dumps(context, indent=2)}\n")
            f.write("-" * 50 + "\n")
    except Exception as e:
        logging.error(f"Failed to write to error log: {e}")

# Main execution
if __name__ == "__main__":
    # Add any additional setup if necessary
    logging.basicConfig(level=logging.INFO)
    logging.info("Script started")
