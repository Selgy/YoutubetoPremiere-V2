import os
import subprocess
import logging
import yt_dlp  # Import yt_dlp directly
import re
from flask import jsonify
import sys
import platform
import time
import requests
from utils import (
    is_premiere_running,
    import_video_to_premiere,
    sanitize_title,
    generate_new_filename,
    play_notification_sound,
    get_default_download_path,
    get_license_key
)
import traceback
import glob
import json
import tempfile
import shutil
from yt_dlp.utils import download_range_func  # Importer la fonction correcte
import urllib.parse as urlparse

# Global variable to store emit_to_client_type function
_emit_to_client_type = None

def set_emit_function(emit_function):
    """Set the emit_to_client_type function for targeted client emissions"""
    global _emit_to_client_type
    _emit_to_client_type = emit_function

def emit_targeted(event, data, client_type=None, socketio=None):
    """Emit event to specific client type if available, otherwise broadcast"""
    if _emit_to_client_type and client_type:
        _emit_to_client_type(event, data, client_type)
    elif socketio:
        socketio.emit(event, data)
    else:
        logging.warning(f"Could not emit event {event}: no emission method available")

def get_subprocess_creation_flags():
    """Get Windows-specific creation flags to hide console windows"""
    if sys.platform == 'win32':
        # On Windows, use these flags to hide the console window
        import subprocess
        return subprocess.CREATE_NO_WINDOW | subprocess.DETACHED_PROCESS
    return 0

def run_hidden_subprocess(cmd, **kwargs):
    """Run subprocess with hidden console window on Windows"""
    if sys.platform == 'win32':
        # Add Windows-specific flags to hide console window
        creation_flags = get_subprocess_creation_flags()
        kwargs['creationflags'] = creation_flags
        kwargs['startupinfo'] = subprocess.STARTUPINFO()
        kwargs['startupinfo'].dwFlags |= subprocess.STARTF_USESHOWWINDOW
        kwargs['startupinfo'].wShowWindow = subprocess.SW_HIDE
    
    return subprocess.run(cmd, **kwargs)

def get_ffmpeg_postprocessor_args():
    """Get FFmpeg arguments that help hide console windows"""
    args = ['-y']  # Overwrite output files
    
    if sys.platform == 'win32':
        # On Windows, add flags to minimize console interaction
        args.extend([
            '-nostdin',      # Don't read from stdin
            '-hide_banner',  # Hide copyright notice
            '-loglevel', 'error'  # Only show errors
        ])
    
    return args

def verify_authentication_cookies(cookies_list):
    """Verify if the cookies contain necessary authentication data for YouTube"""
    if not cookies_list:
        return False, "No cookies provided"
    
    # Check for essential authentication cookies
    auth_cookies = {
        'LOGIN_INFO': False,
        'SAPISID': False,
        'APISID': False,
        '__Secure-3PAPISID': False,
        'SID': False
    }
    
    for cookie in cookies_list:
        name = cookie.get('name', '')
        if name in auth_cookies:
            auth_cookies[name] = True
    
    # Check authentication level
    has_login_info = auth_cookies['LOGIN_INFO']
    has_sapisid = auth_cookies['SAPISID'] or auth_cookies['__Secure-3PAPISID']
    has_sid = auth_cookies['SID']
    
    if has_login_info and has_sapisid:
        return True, "Full authentication detected"
    elif has_sapisid or has_sid:
        return True, "Partial authentication detected"
    else:
        return False, "No authentication cookies found"

def create_cookies_file(cookies_list):
    """Create a temporary cookies file from cookies list"""
    if not cookies_list:
        logging.warning("No cookies provided to create_cookies_file")
        return None
        
    # Verify authentication before creating file
    is_authenticated, auth_status = verify_authentication_cookies(cookies_list)
    logging.info(f"Cookie authentication status: {auth_status}")
    
    if not is_authenticated:
        logging.warning("Warning: No valid authentication cookies found. Downloads may fail for age-restricted content.")
    
    try:
        # Create temp directory
        cookies_dir = os.path.join(os.environ.get('TEMP', tempfile.gettempdir()), 'YoutubetoPremiere')
        os.makedirs(cookies_dir, exist_ok=True)
        
        # Create cookies file with timestamp to avoid conflicts
        import time
        timestamp = int(time.time())
        cookies_file = os.path.join(cookies_dir, f'youtube_cookies_{timestamp}.txt')
        
        logging.info(f"Creating cookies file at: {cookies_file}")
        
        with open(cookies_file, 'w', encoding='utf-8') as f:
            f.write("# Netscape HTTP Cookie File\n")
            f.write("# Generated by YoutubetoPremiere Extension\n")
            f.write(f"# Created: {time.strftime('%Y-%m-%d %H:%M:%S')}\n")
            
            written_cookies = 0
            auth_cookies_written = 0
            
            # Prioritize authentication cookies first
            auth_cookie_names = [
                'LOGIN_INFO', '__Secure-3PAPISID', '__Secure-3PSID', 
                'SAPISID', 'APISID', 'SID', 'HSID', 'SSID', 'SIDCC'
            ]
            
            # Write authentication cookies first
            for cookie in cookies_list:
                name = cookie.get('name', '')
                if name in auth_cookie_names:
                    if write_cookie_to_file(f, cookie, written_cookies):
                        written_cookies += 1
                        auth_cookies_written += 1
            
            # Then write other cookies
            for cookie in cookies_list:
                name = cookie.get('name', '')
                if name not in auth_cookie_names:
                    if write_cookie_to_file(f, cookie, written_cookies):
                        written_cookies += 1
        
        logging.info(f"Created cookies file with {written_cookies} total cookies ({auth_cookies_written} authentication cookies): {cookies_file}")
        
        # Log file size to verify it was created properly
        file_size = os.path.getsize(cookies_file)
        logging.info(f"Cookies file size: {file_size} bytes")
        
        # Validate the file was created properly
        if validate_cookies_file(cookies_file):
            return cookies_file
        else:
            return None
        
    except Exception as e:
        logging.error(f"Error creating cookies file: {e}")
        return None

def write_cookie_to_file(file_handle, cookie, index):
    """Write a single cookie to the file in Netscape format"""
    try:
        domain = cookie.get('domain', '.youtube.com')
        name = cookie.get('name', '')
        value = cookie.get('value', '')
        path = cookie.get('path', '/')
        expires = str(cookie.get('expirationDate', '0'))
        secure = 'TRUE' if cookie.get('secure', False) else 'FALSE'
        
        # Skip invalid cookies
        if not name or not value:
            logging.debug(f"Skipping invalid cookie {index}: name='{name}', value='{value}'")
            return False
        
        # Clean and validate cookie data for Netscape format
        name = str(name).replace('\t', '').replace('\n', '').replace('\r', '')
        value = str(value).replace('\t', '').replace('\n', '').replace('\r', '')
        domain = str(domain).replace('\t', '').replace('\n', '').replace('\r', '')
        path = str(path).replace('\t', '').replace('\n', '').replace('\r', '')
        
        # Skip cookies with problematic values
        if not name or not value or '\t' in name or '\t' in value:
            logging.debug(f"Skipping cookie with problematic format {index}: name='{name[:20]}...', value='{value[:20]}...'")
            return False
        
        # Filter out known problematic cookies that aren't needed for YouTube auth
        problematic_cookies = [
            'GMAIL_AT', 'COMPASS', '__utma', '__utmb', '__utmc', '__utmz', 'IDE', 'DV', 
            'WML', 'GX', 'SMSV', 'ACCOUNT_CHOOSER', 'UULE', '__Host-GMAIL_SCH_GMN',
            '__Host-GMAIL_SCH_GMS', '__Host-GMAIL_SCH_GML', '__Host-GMAIL_SCH',
            '__Host-GAPS', '__Host-1PLSID', '__Host-3PLSID', '__Secure-DIVERSION_ID',
            'LSOLH', '__Secure-ENID', 'OTZ', 'LSID'
        ]
        
        # Filter out __Host-* cookies as they often have problematic formats
        if name.startswith('__Host-') or name in problematic_cookies:
            logging.debug(f"Skipping problematic cookie: {name}")
            return False
        
        # Only keep cookies from core YouTube/Google domains
        allowed_domains = ['.youtube.com', 'www.youtube.com', 'youtube.com', 'm.youtube.com', '.google.com', 'accounts.google.com']
        if domain not in allowed_domains:
            logging.debug(f"Skipping cookie from non-essential domain: {name} from {domain}")
            return False
        
        # Ensure expirationDate is properly formatted
        try:
            expires_float = float(expires) if expires and expires != '0' else 0
            expires = str(int(expires_float)) if expires_float > 0 else '0'
        except (ValueError, TypeError):
            expires = '0'
        
        # Write in Netscape format: domain flag path secure expiration name value
        cookie_line = f"{domain}\tTRUE\t{path}\t{secure}\t{expires}\t{name}\t{value}\n"
        file_handle.write(cookie_line)
        
        # Log important authentication cookies
        if name in ['SAPISID', 'APISID', 'HSID', 'SSID', 'LOGIN_INFO', '__Secure-3PAPISID', '__Secure-3PSID']:
            logging.info(f"Authentication cookie: {name} for domain {domain}")
        
        return True
        
    except Exception as e:
        logging.error(f"Error writing cookie {index}: {e}")
        return False

def validate_cookies_file(cookies_file):
    """Validate that the cookies file was created properly"""
    try:
        with open(cookies_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            
        valid_lines = 0
        for i, line in enumerate(lines):
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            
            # Check if line has correct number of tab-separated fields
            parts = line.split('\t')
            if len(parts) == 7:
                valid_lines += 1
            else:
                logging.warning(f"Invalid Netscape format on line {i+1}: {len(parts)} fields instead of 7")
        
        if valid_lines == 0:
            logging.error("No valid cookies found in generated file")
            return False
        
        logging.info(f"Validated {valid_lines} cookie lines in Netscape format")
        return True
        
    except Exception as e:
        logging.error(f"Error validating cookies file: {e}")
        return False

def get_youtube_cookies_file():
    """Get the path to the YouTube cookies file if it exists"""
    try:
        cookies_dir = os.path.join(os.environ.get('TEMP', tempfile.gettempdir()), 'YoutubetoPremiere')
        cookies_file = os.path.join(cookies_dir, 'youtube_cookies.txt')
        
        if os.path.exists(cookies_file) and os.path.getsize(cookies_file) > 0:
            logging.info(f"Found YouTube cookies file: {cookies_file}")
            return cookies_file
        else:
            logging.info("No YouTube cookies file found")
            return None
    except Exception as e:
        logging.error(f"Error checking for YouTube cookies file: {e}")
        return None

def try_extract_cookies_from_browser():
    """Try to extract cookies from browser using yt-dlp's built-in functionality"""
    try:
        cookies_dir = os.path.join(os.environ.get('TEMP', tempfile.gettempdir()), 'YoutubetoPremiere')
        os.makedirs(cookies_dir, exist_ok=True)
        
        browser_cookies_file = os.path.join(cookies_dir, 'youtube_browser_cookies.txt')
        
        # Try to extract cookies from Chrome first, then Edge, then Firefox
        browsers = ['chrome', 'edge', 'firefox']
        
        for browser in browsers:
            try:
                logging.info(f"Attempting to extract YouTube cookies from {browser}")
                
                # Use yt-dlp to extract cookies from browser
                ydl_opts = {
                    'cookiesfrombrowser': (browser, None, None, None),
                    'extract_flat': True,
                    'quiet': True,
                    'writesubtitles': False,
                    'writeautomaticsub': False,
                    'writedescription': False,
                    'writeinfojson': False,
                    'writethumbnail': False,
                }
                
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    # Test with a simple YouTube URL
                    info = ydl.extract_info('https://www.youtube.com/', download=False)
                    if info:
                        logging.info(f"Successfully extracted cookies from {browser}")
                        return (browser, None, None, None)
                        
            except Exception as e:
                logging.debug(f"Failed to extract cookies from {browser}: {e}")
                continue
        
        logging.warning("Could not extract cookies from any browser")
        return None
        
    except Exception as e:
        logging.error(f"Error in try_extract_cookies_from_browser: {e}")
        return None

def get_ffmpeg_path():
    """Get the path to ffmpeg executable"""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    working_dir = os.getcwd()
    
    # If running from CEP extension, prioritize exec directory
    possible_locations = []
    
    # 1. First priority: current working directory (for CEP)
    if working_dir.endswith('exec'):
        # We're already in the exec directory
        possible_locations.append(working_dir)
    else:
        # Check if we can find the exec directory relative to working dir
        exec_from_working = os.path.join(working_dir, 'exec')
        if os.path.exists(exec_from_working):
            possible_locations.append(exec_from_working)
    
    # 2. Try to find CEP extension directory pattern
    extension_patterns = [
        # Standard CEP extension paths
        os.path.join(os.path.expanduser('~'), 'AppData', 'Roaming', 'Adobe', 'CEP', 'extensions'),
        '/Library/Application Support/Adobe/CEP/extensions',  # macOS
        '~/Library/Application Support/Adobe/CEP/extensions'   # macOS user
    ]
    
    for pattern in extension_patterns:
        expanded_pattern = os.path.expanduser(pattern)
        if os.path.exists(expanded_pattern):
            # Look for our extension
            for ext_dir in os.listdir(expanded_pattern):
                if 'Y2P' in ext_dir or 'youtube' in ext_dir.lower():
                    exec_dir = os.path.join(expanded_pattern, ext_dir, 'exec')
                    if os.path.exists(exec_dir):
                        possible_locations.append(exec_dir)
    
    # 3. Extension root environment variable
    extension_root = os.environ.get('EXTENSION_ROOT', '')
    if extension_root:
        possible_locations.extend([
            extension_root,
            os.path.join(extension_root, 'exec'),
        ])
    
    # 4. Standard fallback locations
    possible_locations.extend([
        os.path.dirname(script_dir),  # Parent directory
        script_dir,  # Current directory
        os.path.join(script_dir, 'ffmpeg'),  # ffmpeg subdirectory
        os.path.join(os.path.dirname(script_dir), 'ffmpeg'),  # Parent's ffmpeg subdirectory
        working_dir,
        os.path.dirname(working_dir),
    ])
    
    # Add macOS specific paths including _internal
    if sys.platform == 'darwin':
        # Add _internal paths for macOS PyInstaller builds
        possible_locations.extend([
            os.path.join(working_dir, '_internal'),
            os.path.join(exec_from_working, '_internal') if 'exec_from_working' in locals() else None,
        ])
        
        # Filter out None values
        possible_locations = [loc for loc in possible_locations if loc is not None]
        
        possible_locations.extend([
            '/usr/local/bin',
            '/opt/homebrew/bin',
            '/usr/bin',
            os.path.expanduser('~/bin'),
            # Add common homebrew installation paths
            '/opt/homebrew/Cellar/ffmpeg',
            '/usr/local/Cellar/ffmpeg'
        ])
        
        # Try to find installed ffmpeg via 'which' command
        try:
            which_result = subprocess.run(['which', 'ffmpeg'], 
                                           stdout=subprocess.PIPE, 
                                           stderr=subprocess.PIPE, 
                                           text=True)
            if which_result.returncode == 0 and which_result.stdout.strip():
                possible_locations.append(os.path.dirname(which_result.stdout.strip()))
                logging.info(f"Found ffmpeg via 'which' at: {which_result.stdout.strip()}")
        except:
            pass
    
    # Filter out empty paths and remove duplicates while preserving order
    possible_locations = list(dict.fromkeys(filter(None, possible_locations)))
    
    ffmpeg_name = 'ffmpeg.exe' if sys.platform == 'win32' else 'ffmpeg'
    
    # First try direct paths
    for location in possible_locations:
        ffmpeg_path = os.path.join(location, ffmpeg_name)
        if os.path.exists(ffmpeg_path):
            logging.info(f"Found ffmpeg at: {ffmpeg_path}")
            # On Windows, use a simpler file existence check when running from Premiere
            if sys.platform == 'win32':
                file_size = os.path.getsize(ffmpeg_path)
                # If the file is large enough to be a valid ffmpeg executable, assume it works
                if file_size > 1000000:  # Typical ffmpeg.exe is several MB
                    logging.info(f"Assuming ffmpeg is valid based on file size ({file_size} bytes): {ffmpeg_path}")
                    return ffmpeg_path
                logging.warning(f"Found ffmpeg at {ffmpeg_path} but size is suspiciously small: {file_size} bytes")
                continue
                
            # On Unix-like systems, verify permissions
            if sys.platform != 'win32':
                if not os.access(ffmpeg_path, os.X_OK):
                    logging.warning(f"FFmpeg found at {ffmpeg_path} but is not executable")
                    continue
                    
            # Try to run ffmpeg -version to verify it works
            try:
                # Use shell=True on Windows to avoid handle issues
                use_shell = sys.platform == 'win32'
                cmd = [ffmpeg_path, '-version'] if not use_shell else f'"{ffmpeg_path}" -version'
                
                result = subprocess.run(
                    cmd,
                    shell=use_shell,
                    stdout=subprocess.PIPE, 
                    stderr=subprocess.PIPE,
                    timeout=5,
                    text=True
                )
                
                if result.returncode == 0:
                    logging.info(f"Verified ffmpeg is working at: {ffmpeg_path}")
                    return ffmpeg_path
                else:
                    logging.warning(f"FFmpeg found at {ffmpeg_path} but failed version check: {result.stderr}")
            except Exception as e:
                logging.warning(f"Error verifying ffmpeg at {ffmpeg_path}: {str(e)}")
                # If on Windows, return the path anyway if the file exists and is large enough
                if sys.platform == 'win32' and os.path.exists(ffmpeg_path) and os.path.getsize(ffmpeg_path) > 1000000:
                    logging.info(f"Despite verification error, using ffmpeg at: {ffmpeg_path}")
                    return ffmpeg_path
                continue
    
    # If not found in standard paths, try looking for ffmpeg in PATH
    try:
        # Try multiple methods to find ffmpeg in PATH
        if sys.platform == 'darwin':
            # On macOS, try running ffmpeg directly as it might be in PATH
            result = subprocess.run(['ffmpeg', '-version'], 
                                 stdout=subprocess.PIPE, 
                                 stderr=subprocess.PIPE,
                                 timeout=5)
            if result.returncode == 0 and 'ffmpeg version' in result.stdout.decode():
                logging.info("Found working ffmpeg in PATH")
                return 'ffmpeg'  # Return just 'ffmpeg' to use PATH resolution
            
            # If direct execution fails, try 'which' command
            which_result = subprocess.run(['which', 'ffmpeg'], 
                                        stdout=subprocess.PIPE, 
                                        stderr=subprocess.PIPE,
                                        text=True)
            if which_result.returncode == 0 and which_result.stdout.strip():
                ffmpeg_in_path = which_result.stdout.strip()
                # Verify this ffmpeg works
                test_result = subprocess.run([ffmpeg_in_path, '-version'],
                                           stdout=subprocess.PIPE,
                                           stderr=subprocess.PIPE,
                                           timeout=5)
                if test_result.returncode == 0:
                    logging.info(f"Found working ffmpeg via which: {ffmpeg_in_path}")
                    return ffmpeg_in_path
                    
        elif sys.platform == 'win32':
            # On Windows, try 'where' command
            where_result = subprocess.run(['where', 'ffmpeg'], 
                                        shell=True,
                                        stdout=subprocess.PIPE, 
                                        stderr=subprocess.PIPE,
                                        text=True)
            if where_result.returncode == 0 and where_result.stdout.strip():
                ffmpeg_in_path = where_result.stdout.strip().split('\n')[0]
                if os.path.exists(ffmpeg_in_path) and os.path.getsize(ffmpeg_in_path) > 1000000:
                    logging.info(f"Found ffmpeg via where: {ffmpeg_in_path}")
                    return ffmpeg_in_path
        
    except Exception as e:
        logging.warning(f"Error checking ffmpeg in PATH: {str(e)}")

    logging.error("FFmpeg not found in any of the expected locations")
    logging.error(f"Searched locations: {possible_locations}")
    
    # Try the app_init module's find_ffmpeg as last resort
    try:
        from app_init import find_ffmpeg as init_find_ffmpeg
        init_ffmpeg = init_find_ffmpeg()
        if init_ffmpeg:
            logging.info(f"Found ffmpeg via app_init module: {init_ffmpeg}")
            return init_ffmpeg
    except Exception as e:
        logging.warning(f"Error using app_init find_ffmpeg: {str(e)}")
        
    return None

def check_ffmpeg(settings, socketio):
    """Check if ffmpeg is available and working"""
    ffmpeg_path = get_ffmpeg_path()
    if not ffmpeg_path:
        error_msg = "FFmpeg not found. Please ensure ffmpeg is properly installed."
        logging.error(error_msg)
        if socketio:
            socketio.emit('error', {'message': error_msg})
        return {'success': False, 'message': error_msg}
    
    # Verify FFmpeg actually works
    try:
        if ffmpeg_path == 'ffmpeg':
            # If it's just 'ffmpeg', try to run it directly (PATH resolution)
            test_cmd = ['ffmpeg', '-version']
        else:
            # Use the full path
            test_cmd = [ffmpeg_path, '-version']
        
        # Test FFmpeg
        result = subprocess.run(test_cmd, 
                              capture_output=True, 
                              text=True, 
                              timeout=10)
        
        if result.returncode == 0 and 'ffmpeg version' in result.stdout:
            logging.info(f"FFmpeg verified and working: {ffmpeg_path}")
            # Store the verified path in settings for later use
            if settings is not None:
                settings['ffmpeg_path'] = ffmpeg_path
            return {'success': True, 'path': ffmpeg_path}
        else:
            error_msg = f"FFmpeg found but not working properly: {ffmpeg_path}"
            logging.error(error_msg)
            logging.error(f"FFmpeg test output: {result.stderr}")
            if socketio:
                socketio.emit('error', {'message': error_msg})
            return {'success': False, 'message': error_msg}
            
    except subprocess.TimeoutExpired:
        error_msg = f"FFmpeg test timed out: {ffmpeg_path}"
        logging.error(error_msg)
        if socketio:
            socketio.emit('error', {'message': error_msg})
        return {'success': False, 'message': error_msg}
    except Exception as e:
        error_msg = f"Error testing FFmpeg: {str(e)}"
        logging.error(error_msg)
        if socketio:
            socketio.emit('error', {'message': error_msg})
        # On macOS, if direct test fails but file exists, try to continue anyway
        if sys.platform == 'darwin' and ffmpeg_path != 'ffmpeg':
            if os.path.exists(ffmpeg_path) and os.access(ffmpeg_path, os.X_OK):
                logging.warning(f"FFmpeg test failed but file exists and is executable, continuing anyway: {ffmpeg_path}")
                if settings is not None:
                    settings['ffmpeg_path'] = ffmpeg_path
                return {'success': True, 'path': ffmpeg_path}
        return {'success': False, 'message': error_msg}

def validate_license(license_key):
    if not license_key:
        return False

    # Try Gumroad validation
    try:
        gumroad_response = requests.post('https://api.gumroad.com/v2/licenses/verify', {
            'product_id': '9yYJT15dJO3wB4Z74N-EUg==',
            'license_key': license_key
        })

        if gumroad_response.ok and gumroad_response.json().get('success'):
            return True

        # Try Shopify validation
        api_token = 'eHyU10yFizUV5qUJaFS8koE1nIx2UCDFNSoPVdDRJDI7xtunUK6ZWe40vfwp'
        shopify_response = requests.post(
            f'https://app-easy-product-downloads.fr/api/get-license-key',
            params={'license_key': license_key, 'api_token': api_token}
        )

        if shopify_response.ok and shopify_response.json().get('status') == 'success':
            return True

    except Exception as e:
        logging.error(f"Error validating license: {e}")
        return False

    return False

def handle_video_url(video_url, download_type, current_download, socketio, settings, clip_start=None, clip_end=None, cookies=None, user_agent=None):
    """
    Handle video URL processing based on the download type.
    """
    try:
        # Validate and prepare environment
        ffmpeg_check_result = check_ffmpeg(settings, socketio)
        if not ffmpeg_check_result['success']:
            return {"error": ffmpeg_check_result['message']}
        
        # Get FFmpeg path
        ffmpeg_path = ffmpeg_check_result['path']
        if not ffmpeg_path:
            return {"error": "FFmpeg path not set in settings"}
            
        # Get download parameters from settings
        resolution = settings.get('resolution', '1080')
        download_mp3 = settings.get('downloadMP3', False)
        download_path = settings.get('downloadPath', '')
        
        # Validate license if required
        if download_type == 'video':
            license_valid = validate_license(settings.get('licenseKey'))
            if not license_valid:
                return {"error": "Invalid license. Please purchase a license to download videos."}
        
        # If no download path is set, use a default path
        if not download_path:
            download_path = get_default_download_path(socketio)
            if not download_path:
                return {"error": "Download path not set and could not determine default"}
        
        logging.info(f"Processing {download_type} request for {video_url}")
        logging.info(f"Settings: resolution={resolution}, download_path={download_path}, download_mp3={download_mp3}")
        
        if download_type == 'audio':
            # Process audio download
            result = download_audio(
                video_url=video_url, 
                download_path=download_path,
                ffmpeg_path=ffmpeg_path,
                socketio=socketio,
                current_download=current_download,
                settings=settings,
                cookies=cookies,
                user_agent=user_agent
            )
            
            if result and os.path.exists(result):
                socketio.emit('import_video', {'path': result})
                return {"success": True, "path": result}
            else:
                return {"error": "Failed to download audio"}
                
        elif download_type == 'clip':
            # Validate clip parameters
            if clip_start is None or clip_end is None:
                return {"error": "Clip start and end times must be provided"}
                
            if clip_start >= clip_end:
                return {"error": "Clip start time must be less than end time"}
            
            # Process clip download
            result = download_and_process_clip(
                video_url=video_url,
                resolution=resolution,
                download_path=download_path,
                clip_start=clip_start,
                clip_end=clip_end,
                download_mp3=download_mp3,
                ffmpeg_path=ffmpeg_path,
                socketio=socketio,
                settings=settings,
                current_download=current_download,
                cookies=cookies,
                user_agent=user_agent
            )
            
            if result and result.get("success") and result.get("path") and os.path.exists(result["path"]):
                socketio.emit('import_video', {'path': result["path"]})
                return {"success": True, "path": result["path"]}
            else:
                error_msg = result.get("error") if result and "error" in result else "Failed to download clip"
                return {"error": error_msg}
        else:
            # Process regular video download (default case)
            result = download_video(
                video_url=video_url,
                resolution=resolution,
                download_path=download_path,
                download_mp3=download_mp3,
                ffmpeg_path=ffmpeg_path,
                socketio=socketio,
                settings=settings,
                current_download=current_download,
                cookies=cookies,
                user_agent=user_agent
            )
            
            if result and os.path.exists(result):
                socketio.emit('import_video', {'path': result})
                return {"success": True, "path": result}
            else:
                return {"error": "Failed to download video"}
                
    except Exception as e:
        error_message = f"Error processing URL: {str(e)}"
        context = {
            'video_url': video_url,
            'download_type': download_type,
            'settings': {k: v for k, v in settings.items() if k not in ['licenseKey']},  # Exclude sensitive data
            'clip_start': clip_start,
            'clip_end': clip_end
        }
        write_error_log(error_message, context)
        logging.error(error_message)
        return {"error": error_message}

def sanitize_resolution(resolution):
    """Convert resolution string to a clean integer value"""
    if isinstance(resolution, int):
        return resolution
    
    # Strip 'p' suffix if present
    if isinstance(resolution, str):
        resolution = resolution.lower().replace('p', '').strip()
    
    # Convert to integer
    try:
        return int(resolution)
    except (ValueError, TypeError):
        # Default to 1080 if conversion fails
        return 1080

def download_and_process_clip(video_url, resolution, download_path, clip_start, clip_end, download_mp3, ffmpeg_path, socketio, settings, current_download, cookies=None, user_agent=None):
    clip_duration = clip_end - clip_start
    logging.info(f"Received clip parameters: clip_start={clip_start}, clip_end={clip_end}, clip_duration={clip_duration}")

    # Check if download path exists or try to get default path
    if not download_path:
        download_path = get_default_download_path(socketio)
        if not download_path:
            error_msg = "Could not determine download path. Please open a Premiere Pro project."
            logging.error(error_msg)
            socketio.emit('download-failed', {'message': error_msg})
            return {"error": error_msg}
            
    logging.info(f"Using download path: {download_path}")

    # Ensure the path exists
    try:
        os.makedirs(download_path, exist_ok=True)
        logging.info(f"Ensured download directory exists: {download_path}")
    except Exception as e:
        error_msg = f"Could not create download directory: {str(e)}"
        logging.error(error_msg)
        socketio.emit('download-failed', {'message': error_msg})
        return {"error": error_msg}

    try:
        # Ensure ffmpeg path is valid
        if not ffmpeg_path:
            logging.error("FFmpeg path not provided")
            socketio.emit('download-failed', {'message': 'FFmpeg not found. Please check settings.'})
            return {"error": "FFmpeg not found at specified path"}
            
        # Start with loading animation - no percentage for clips
        pass
                
        # Handle cancellation
        is_cancelled = [False]
        def cancel_callback():
            is_cancelled[0] = True
            return is_cancelled[0]
        
        current_download['cancel_callback'] = cancel_callback
                
        # Get sanitized title for the output file with authentication
        sanitized_title = ''
        try:
            # Use same authentication as download for title extraction
            title_ydl_opts = {'quiet': True, 'skip_download': True}
            
            # Apply authentication for title extraction
            cookies_file = None
            if cookies:
                cookies_file = create_cookies_file(cookies)
                if not cookies_file:
                    cookies_file = get_youtube_cookies_file()
            else:
                cookies_file = get_youtube_cookies_file()
                if not cookies_file:
                    browser_cookies = try_extract_cookies_from_browser()
                    if browser_cookies:
                        title_ydl_opts['cookiesfrombrowser'] = browser_cookies
                        logging.info(f"Using cookies from browser for title extraction: {browser_cookies[0]}")
            
            if cookies_file and os.path.exists(cookies_file):
                title_ydl_opts['cookiefile'] = cookies_file
                logging.info(f"Using cookies file for title extraction: {cookies_file}")
            
            if user_agent:
                title_ydl_opts['http_headers'] = {'User-Agent': user_agent}
                logging.info("Using User-Agent from extension for title extraction")
            
            with yt_dlp.YoutubeDL(title_ydl_opts) as ydl:
                video_info = ydl.extract_info(video_url, download=False)
                if video_info:
                    sanitized_title = sanitize_youtube_title(video_info.get('title', 'video'))
                    logging.info(f"Successfully extracted title for clip: {sanitized_title}")
                else:
                    sanitized_title = 'clip_' + str(int(time.time()))
        except Exception as e:
            logging.error(f"Error extracting video info for clip naming: {str(e)}")
            sanitized_title = 'clip_' + str(int(time.time()))
            
        # Get unique filename
        unique_filename = get_unique_filename(download_path, sanitized_title + '_clip', 'mp4')
        video_file_path = os.path.join(download_path, unique_filename)
        logging.info(f"Setting output path to: {video_file_path}")

        # Get preferred audio language from settings
        preferred_language = settings.get('preferredAudioLanguage', 'original')
        logging.info(f"Using preferred audio language for clip: {preferred_language}")
        
        # Format string for the desired quality - FORCE AVC1 CODEC with language preference
        sanitized_resolution = sanitize_resolution(resolution)
        if preferred_language != 'original':
            format_str = f'bestvideo[height<={sanitized_resolution}][vcodec^=avc1][ext=mp4]+bestaudio[ext=m4a][language~="{preferred_language}"]/bestvideo[height<={sanitized_resolution}][vcodec^=avc1][ext=mp4]+bestaudio[ext=m4a]/best[vcodec^=avc1][ext=mp4]/best'
        else:
            format_str = f'bestvideo[height<={sanitized_resolution}][vcodec^=avc1][ext=mp4]+bestaudio[ext=m4a]/best[vcodec^=avc1][ext=mp4]/best'
        logging.info(f"Using format string with AVC1 codec and language preference: {format_str}")
        
        # CORRECTION: Utiliser download_ranges au lieu de download_sections
        logging.info(f"Using download ranges: start={clip_start}, end={clip_end}")
        
        # Progress hook to track download progress and send updates
        # Progress throttling variables for clips
        last_progress_time_clip = [0]  # Use list to make it mutable in nested function
        last_progress_value_clip = [0]
        
        def progress_hook(d):
            if is_cancelled[0]:
                return
                
            if d['status'] == 'downloading':
                try:
                    percentage = d.get('_percent_str', '0%')
                    # Remove ANSI color codes if present
                    percentage = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', percentage)
                    percentage = percentage.strip()
                    logging.info(f'[PROGRESS] Clip Progress: {percentage}')
                    # No percentage emission for clips - just keep loading animation
                except Exception as e:
                    logging.error(f"Error in clip progress hook: {e}")
            elif d['status'] == 'finished':
                logging.info('[FINISHED] Clip download finished')
                # No percentage emission for clips - animation will stop when complete

        # Configure yt-dlp options with robust settings for clip download
        ydl_opts = get_robust_ydl_options(ffmpeg_path)
        ydl_opts.update({
            'format': format_str,
            'outtmpl': video_file_path,
            'force_keyframes_at_cuts': True,
            'download_ranges': download_range_func(None, [(clip_start, clip_end)]),  # Use correct function
            'no_part': True,
            'progress_hooks': [progress_hook],
        })
        
        # Apply authentication for clip download
        cookies_file = None
        if cookies:
            cookies_file = create_cookies_file(cookies)
            if not cookies_file:
                cookies_file = get_youtube_cookies_file()
        else:
            cookies_file = get_youtube_cookies_file()
            if not cookies_file:
                browser_cookies = try_extract_cookies_from_browser()
                if browser_cookies:
                    ydl_opts['cookiesfrombrowser'] = browser_cookies
                    logging.info(f"Using cookies from browser for clip download: {browser_cookies[0]}")
        
        if cookies_file and os.path.exists(cookies_file):
            ydl_opts['cookiefile'] = cookies_file
            logging.info(f"Using cookies file for clip download: {cookies_file}")
        
        if user_agent:
            ydl_opts['http_headers'] = {'User-Agent': user_agent}
            logging.info("Using User-Agent from extension for clip download")
        
        # Download with yt-dlp
        # Note: We need to allow yt-dlp to capture progress information
        # so we can't completely redirect stdout/stderr on Windows.
        # Instead, we'll use a safer approach that preserves progress hooks
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                current_download['ydl'] = ydl
                
                # Log the environment variables related to ffmpeg
                logging.info(f"Environment PATH: {os.environ.get('PATH')}")
                logging.info(f"Environment FFMPEG_PATH: {os.environ.get('FFMPEG_PATH')}")
                
                # Verify ffmpeg actually exists at the path
                if not os.path.exists(ffmpeg_path):
                    logging.error(f"FFmpeg executable not found at configured path: {ffmpeg_path}")
                    socketio.emit('download-failed', {'message': f"FFmpeg executable not found at: {ffmpeg_path}"})
                    return {"error": f"FFmpeg executable not found at: {ffmpeg_path}"}
                
                logging.info(f"Starting clip download for {video_url} using ffmpeg at {ffmpeg_path}")
                
                # Emit initial progress for clip
                progress_data = {
                    'progress': '0',
                    'percentage': '0%',
                    'type': 'clip',
                    'status': 'downloading'
                }
                socketio.emit('progress', progress_data)
                socketio.emit('percentage', {'percentage': '0%'})
                
                ydl.download([video_url])
                
                # Check if the download was canceled
                if is_cancelled[0]:
                    if os.path.exists(video_file_path):
                        os.remove(video_file_path)
                    return {"error": "Download cancelled by user"}
                        
            except Exception as e:
                error_message = f"Error downloading clip: {str(e)}"
                logging.error(error_message)
                logging.error(f"Exception type: {type(e).__name__}")
                logging.error(f"Exception traceback: {traceback.format_exc()}")
                
                # Check for Windows-specific stdout/stderr issues
                if "[Errno 22]" in str(e) or "Invalid argument" in str(e):
                    error_message = "Clip download failed due to Windows output stream issue. This is a known yt-dlp issue on Windows. Please try again or restart the application."
                    logging.error("Windows stdout/stderr pipe error detected during clip download - recommending restart")
                # Check if error is related to ffmpeg
                elif 'ffmpeg' in str(e).lower() or 'executable' in str(e).lower():
                    logging.error(f"FFmpeg-related error detected. Current ffmpeg path: {ffmpeg_path}")
                    # Suggest potential solutions
                    solutions = "Try restarting the application or using a different clip download approach."
                    error_message += f" This appears to be related to ffmpeg. {solutions}"
                
                socketio.emit('download-failed', {'message': error_message})
                return {"error": error_message}
            finally:
                current_download['ydl'] = None
                current_download['cancel_callback'] = None

        # Add metadata to the video file if it exists
        if os.path.exists(video_file_path):
            logging.info(f"Clip downloaded successfully: {video_file_path}")

            # Add URL to metadata using hidden subprocess to prevent CMD popup
            metadata_command = [
                ffmpeg_path,
                '-i', video_file_path,
                '-metadata', f'comment={video_url}',
                '-metadata', f'clip_start={clip_start}',
                '-metadata', f'clip_end={clip_end}',
                '-codec', 'copy'
            ] + get_ffmpeg_postprocessor_args() + [
                f'{video_file_path}_with_metadata.mp4'
            ]

            try:
                run_hidden_subprocess(metadata_command, check=True, capture_output=True, text=True)
                os.replace(f'{video_file_path}_with_metadata.mp4', video_file_path)
                logging.info(f"Metadata added: {video_file_path}")
                
                # Emit events
                socketio.emit('complete', {'type': 'clip', 'message': 'Clip téléchargé avec succès'})
                socketio.emit('download-complete', {'url': video_url, 'path': video_file_path})
                socketio.emit('import_video', {'path': video_file_path})
                return {"success": True, "path": video_file_path}
            except subprocess.CalledProcessError as e:
                logging.error(f"Error adding metadata: {e.stderr}")
                # Continue anyway, as the clip itself is fine
                socketio.emit('download-complete', {'url': video_url, 'path': video_file_path})
                socketio.emit('import_video', {'path': video_file_path})
                return {"success": True, "path": video_file_path}
        else:
            error_message = "Clip download failed - output file not found"
            logging.error(error_message)
            socketio.emit('download-failed', {'message': error_message})
            return {"error": error_message}

    except Exception as e:
        error_message = f"Error downloading clip: {str(e)}"
        logging.error(error_message)
        logging.error(f"Full error details: {type(e).__name__}")
        socketio.emit('download-failed', {'message': error_message})
        return {"error": error_message}

def sanitize_youtube_title(title):
    # Remove invalid filename characters and strip excess whitespace
    sanitized_title = re.sub(r'[<>:"/\\|?*\x00-\x1F]', '', title).strip()
    # Replace problematic characters with underscores
    sanitized_title = re.sub(r'\s+', '_', sanitized_title)
    return sanitized_title

def get_unique_filename(base_path, filename, extension):
    """
    Generate a unique filename by adding incremental numbers if the file already exists.
    Example: if 'video.mp4' exists, try 'video_1.mp4', 'video_2.mp4', etc.
    """
    if not os.path.exists(os.path.join(base_path, f"{filename}.{extension}")):
        return f"{filename}.{extension}"
    
    counter = 1
    while os.path.exists(os.path.join(base_path, f"{filename}_{counter}.{extension}")):
        counter += 1
    
    return f"{filename}_{counter}.{extension}"

def download_video(video_url, resolution, download_path, download_mp3, ffmpeg_path, socketio, settings, current_download, cookies=None, user_agent=None):
    check_result = check_ffmpeg(settings, socketio)
    if not check_result['success']:
        return None

    try:
        import yt_dlp

        # Progress throttling variables (use lists to make them mutable in nested functions)
        last_progress_time = [0]
        last_progress_value = [0]
        
        # Simple progress hook like the old working version
        def progress_hook(d):
            if d['status'] == 'downloading':
                try:
                    percentage = d.get('_percent_str', '0%')
                    # Remove ANSI color codes if present
                    percentage = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', percentage)
                    percentage = percentage.strip()
                    logging.info(f'[PROGRESS] Video Progress: {percentage}')
                    # Simple emission like the old version
                    socketio.emit('percentage', {'percentage': percentage})
                except Exception as e:
                    logging.error(f"Error in progress hook: {e}")
            elif d['status'] == 'finished':
                logging.info('[FINISHED] Video download finished')
                socketio.emit('percentage', {'percentage': '100%'})

        # Get preferred audio language from settings
        preferred_language = settings.get('preferredAudioLanguage', 'original')
        logging.info(f"Using preferred audio language: {preferred_language}")
        
        # Create robust format string with fallback options
        max_height = int(resolution.replace("p", ""))
        
        # Start with AVC1 preferences but add robust fallbacks for SABR streaming
        format_options = []
        
        if preferred_language != 'original':
            # Language-specific AVC1 formats first
            format_options.extend([
                f'bestvideo[vcodec^=avc1][height<={max_height}]+bestaudio[language~="{preferred_language}"][ext=m4a]',
                f'best[vcodec^=avc1][height<={max_height}][language~="{preferred_language}"]',
                f'bestvideo[vcodec^=avc1][height<={max_height}]+bestaudio[language~="{preferred_language}"]',
            ])
        
        # AVC1 preferences with SABR-compatible options
        format_options.extend([
            f'bestvideo[vcodec^=avc1][height<={max_height}]+bestaudio[ext=m4a]',    # AVC1 + M4A (preferred)
            f'best[vcodec^=avc1][height<={max_height}][ext=mp4]',                   # AVC1 combined MP4
            f'best[vcodec^=avc1][height<={max_height}]',                            # Any AVC1 format
            f'bestvideo[vcodec^=avc1][height<={max_height}]+bestaudio',             # AVC1 video + any audio
        ])
        
        # Add fallback options that work better with SABR streaming
        format_options.extend(get_fallback_format_options(max_height))
        
        format_string = '/'.join(format_options)
        logging.info(f"Using robust format string with {len(format_options)} options (AVC1 + SABR fallbacks): {format_string[:200]}...")

        # Check if download path exists or try to get default path
        if not download_path:
            download_path = get_default_download_path(socketio)
            if not download_path:
                error_msg = "Could not determine download path. Please open a Premiere Pro project."
                logging.error(error_msg)
                socketio.emit('download-failed', {'message': error_msg})
                return None
            
        logging.info(f"Using download path: {download_path}")

        # Ensure the path exists
        try:
            os.makedirs(download_path, exist_ok=True)
            logging.info(f"Ensured download directory exists: {download_path}")
        except Exception as e:
            error_msg = f"Could not create download directory: {str(e)}"
            logging.error(error_msg)
            socketio.emit('download-failed', {'message': error_msg})
            return None

        # Configure initial yt-dlp options with robust settings
        initial_ydl_opts = get_robust_ydl_options(ffmpeg_path)
        initial_ydl_opts['skip_download'] = True  # Only extract info
        
        # Apply authentication to initial options
        cookies_file = None
        if cookies:
            cookies_file = create_cookies_file(cookies)
            if not cookies_file:
                # Fallback to manual cookies file
                cookies_file = get_youtube_cookies_file()
        else:
            # Check for manual cookies file or try browser extraction
            cookies_file = get_youtube_cookies_file()
            if not cookies_file:
                browser_cookies = try_extract_cookies_from_browser()
                if browser_cookies:
                    initial_ydl_opts['cookiesfrombrowser'] = browser_cookies
                    logging.info(f"Using cookies from browser for info extraction: {browser_cookies[0]}")
        
        if cookies_file and os.path.exists(cookies_file):
            initial_ydl_opts['cookiefile'] = cookies_file
            logging.info(f"Using cookies file for info extraction: {cookies_file}")
        
        if user_agent:
            initial_ydl_opts['http_headers'] = {'User-Agent': user_agent}
            logging.info("Using User-Agent from extension for info extraction")
        
        # Extract video info first with authentication
        with yt_dlp.YoutubeDL(initial_ydl_opts) as ydl:
            info = ydl.extract_info(video_url, download=False)
            if not info:
                raise Exception("Could not extract video information")
            
            # Check if any video formats are available (accept both combined and separate video/audio streams)
            all_formats = info.get('formats', [])
            video_formats = [f for f in all_formats if f.get('vcodec') != 'none']  # Video streams (can be video-only)
            audio_formats = [f for f in all_formats if f.get('acodec') != 'none']  # Audio streams (can be audio-only)
            combined_formats = [f for f in all_formats if f.get('vcodec') != 'none' and f.get('acodec') != 'none']  # Combined streams
            
            if not video_formats:
                error_msg = "This URL contains only images or is not a valid video. Please provide a URL to a video."
                logging.error(error_msg)
                logging.error(f"Available formats: {[f.get('format_id', 'unknown') + ' - ' + str(f.get('vcodec', 'none')) + '/' + str(f.get('acodec', 'none')) for f in all_formats[:5]]}")
                socketio.emit('download-failed', {'message': error_msg})
                return None
            
            logging.info(f"Found {len(video_formats)} video formats, {len(audio_formats)} audio formats, {len(combined_formats)} combined formats")

            # Get video details
            title = info.get('title', 'video')
            
            # Sanitize the title
            sanitized_title = sanitize_youtube_title(title)
            logging.info(f"Sanitized title: {sanitized_title}")
            
            # Get unique filename
            unique_filename = get_unique_filename(download_path, sanitized_title, 'mp4')
            output_path = os.path.join(download_path, unique_filename)
            logging.info(f"Setting output path to: {output_path}")

            # Configure download options with robust settings
            ydl_opts = get_robust_ydl_options(ffmpeg_path)
            ydl_opts.update({
                'format': format_string,
                'merge_output_format': 'mp4',
                'progress_hooks': [progress_hook],
                'postprocessor_hooks': [lambda d: socketio.emit('percentage', {'percentage': '100%'}) if d['status'] == 'finished' else None],
                'outtmpl': {
                    'default': os.path.join(download_path, os.path.splitext(unique_filename)[0] + '.%(ext)s')
                }
            })
            
            # Apply same authentication as info extraction
            if cookies_file and os.path.exists(cookies_file):
                ydl_opts['cookiefile'] = cookies_file
                logging.info(f"Using cookies file for download: {cookies_file}")
            elif 'cookiesfrombrowser' in initial_ydl_opts:
                ydl_opts['cookiesfrombrowser'] = initial_ydl_opts['cookiesfrombrowser']
                logging.info("Using browser cookies for download")
            
            if user_agent:
                ydl_opts['http_headers'] = {'User-Agent': user_agent}
                logging.info("Using User-Agent from extension for download")

            # Download the video
            logging.info("Starting video download...")
            logging.info(f"[CONFIG] Progress hook configured: {progress_hook}")
            logging.info(f"[CONFIG] YT-DLP options include progress_hooks: {'progress_hooks' in ydl_opts}")
            
            # Emit initial progress
            progress_data = {
                'progress': '0',
                'percentage': '0%',
                'type': 'full',
                'status': 'downloading'
            }
            socketio.emit('progress', progress_data)
            socketio.emit('percentage', {'percentage': '0%'})
            logging.info(f"[SENT] initial progress events: progress={progress_data}")
            
            # Configure stdout/stderr to prevent Windows pipe issues
            import contextlib
            import io
            
            # Note: We need to allow yt-dlp to capture progress information
            # so we can't completely redirect stdout/stderr on Windows.
            # Instead, we'll use a safer approach that preserves progress hooks
            try:
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    current_download['ydl'] = ydl
                    ydl.process_ie_result(info, download=True)
            except Exception as e:
                error_message = f"Error during video download: {str(e)}"
                logging.error(error_message)
                logging.error(f"Exception type: {type(e).__name__}")
                logging.error(f"Exception traceback: {traceback.format_exc()}")
                
                # Check for Windows-specific stdout/stderr issues
                if "[Errno 22]" in str(e) or "Invalid argument" in str(e):
                    error_message = "Video download failed due to Windows output stream issue. This is a known yt-dlp issue on Windows. Please try again or restart the application."
                    logging.error("Windows stdout/stderr pipe error detected during video download - recommending restart")
                
                socketio.emit('download-failed', {'message': error_message})
                raise e
            finally:
                current_download['ydl'] = None

            # Get the final path of the downloaded file
            final_path = output_path
            logging.info(f"Expected final path: {final_path}")

            # Check for downloaded files - first try exact path, then look for variants
            actual_file = None
            
            if os.path.exists(final_path):
                actual_file = final_path
                logging.info(f"File exists at expected path: {final_path}")
            else:
                # Look for separate video/audio files that need merging
                base_name = os.path.splitext(final_path)[0]
                base_dir = os.path.dirname(final_path)
                
                # Common yt-dlp separate file patterns
                video_patterns = [f"{base_name}.f*.mp4", f"{base_name}.mp4.f*"]
                audio_patterns = [f"{base_name}.f*.m4a", f"{base_name}.m4a.f*", 
                                f"{base_name}.f*.mp3", f"{base_name}.mp3.f*"]
                
                import glob
                video_files = []
                audio_files = []
                
                # Find video and audio files
                for pattern in video_patterns:
                    video_files.extend(glob.glob(pattern))
                for pattern in audio_patterns:
                    audio_files.extend(glob.glob(pattern))
                
                logging.info(f"Found video files: {video_files}")
                logging.info(f"Found audio files: {audio_files}")
                
                if video_files and audio_files:
                    # Merge video and audio files
                    video_file = video_files[0]  # Use first found
                    audio_file = audio_files[0]  # Use first found
                    
                    logging.info(f"Merging {video_file} and {audio_file} into {final_path}")
                    
                    merge_command = [
                        ffmpeg_path,
                        '-i', video_file,
                        '-i', audio_file,
                        '-c:v', 'copy',
                        '-c:a', 'aac'
                    ] + get_ffmpeg_postprocessor_args() + [
                        final_path
                    ]
                    
                    try:
                        run_hidden_subprocess(merge_command, check=True, capture_output=True, text=True)
                        logging.info(f"Successfully merged files into: {final_path}")
                        
                        # Clean up separate files
                        try:
                            os.remove(video_file)
                            os.remove(audio_file)
                            logging.info("Cleaned up temporary separate files")
                        except Exception as e:
                            logging.warning(f"Could not clean up temporary files: {e}")
                        
                        actual_file = final_path
                        
                    except subprocess.CalledProcessError as e:
                        logging.error(f"Error merging files: {e}")
                        if e.stderr:
                            logging.error(f"FFmpeg stderr: {e.stderr}")
                        # Don't fail completely - maybe one of the files is usable
                        if os.path.exists(video_file):
                            # Use video file if it exists and seems complete
                            actual_file = video_file
                            logging.info(f"Using video file as fallback: {video_file}")
                
                # If still no file, look for any files with similar names
                if not actual_file:
                    all_files = os.listdir(base_dir) if os.path.exists(base_dir) else []
                    base_filename = os.path.basename(base_name)
                    
                    # Look for files that start with our base filename
                    candidates = [f for f in all_files if f.startswith(base_filename) and f.endswith(('.mp4', '.mkv', '.webm'))]
                    
                    if candidates:
                        # Use the most recently modified file
                        candidates_full = [os.path.join(base_dir, f) for f in candidates]
                        candidates_full.sort(key=os.path.getmtime, reverse=True)
                        actual_file = candidates_full[0]
                        logging.info(f"Using most recent candidate file: {actual_file}")
                        
                        # Move it to the expected location if different
                        if actual_file != final_path:
                            try:
                                os.rename(actual_file, final_path)
                                actual_file = final_path
                                logging.info(f"Moved file to expected location: {final_path}")
                            except Exception as e:
                                logging.warning(f"Could not move file to expected location: {e}")

            if actual_file and os.path.exists(actual_file):
                logging.info(f"Using file: {actual_file}")
                
                # Add URL to metadata
                metadata_command = [
                    ffmpeg_path,  # Use the full path here
                    '-i', actual_file,
                    '-metadata', f'comment={video_url}',
                    '-codec', 'copy'
                ] + get_ffmpeg_postprocessor_args() + [
                    f'{actual_file}_with_metadata.mp4'
                ]
                logging.info(f"Running FFmpeg command: {' '.join(metadata_command)}")

                try:
                    run_hidden_subprocess(metadata_command, check=True)
                    os.replace(f'{actual_file}_with_metadata.mp4', actual_file)
                    
                    logging.info(f"Video downloaded and processed: {actual_file}")
                    socketio.emit('import_video', {'path': actual_file})
                    # Emit both formats to ensure compatibility
                    socketio.emit('download-complete', {'url': video_url, 'path': actual_file})  # Hyphenated format for Chrome extension
                    
                    return actual_file
                except subprocess.CalledProcessError as e:
                    logging.error(f"Error adding metadata: {e}")
                    logging.error(f"FFmpeg stderr: {e.stderr if hasattr(e, 'stderr') else 'No stderr'}")
                    # Still return the file even if metadata failed
                    logging.info(f"Returning file without metadata: {actual_file}")
                    socketio.emit('import_video', {'path': actual_file})
                    socketio.emit('download-complete', {'url': video_url, 'path': actual_file})
                    return actual_file
            else:
                logging.error(f"No suitable file found. Expected: {final_path}")
                # List all files in directory for debugging
                try:
                    all_files = os.listdir(os.path.dirname(final_path))
                    logging.error(f"Files in download directory: {all_files}")
                except Exception as e:
                    logging.error(f"Could not list directory contents: {e}")
                
                raise Exception(f"Downloaded file not found at {final_path}")

    except Exception as e:
        error_message = f"Error downloading video: {str(e)}"
        logging.error(error_message)
        logging.error(f"Exception type: {type(e)}")
        logging.error(f"Exception traceback: {traceback.format_exc()}")
        
        # Check for Windows-specific stdout/stderr issues
        if "[Errno 22]" in str(e) or "Invalid argument" in str(e):
            error_message = "Download failed due to Windows output stream issue. This is a known yt-dlp issue on Windows. Please try again or restart the application."
            logging.error("Windows stdout/stderr pipe error detected - recommending restart")
        
        socketio.emit('download-failed', {'message': error_message})
        return None

def download_audio(video_url, download_path, ffmpeg_path, socketio, current_download=None, settings=None, cookies=None, user_agent=None):
    check_result = check_ffmpeg(None, socketio)
    if not check_result['success']:
        return None

    try:
        # Clean the URL first - remove playlist and other problematic parameters
        parsed_url = urlparse.urlparse(video_url)
        
        # Keep only essential parameters for YouTube URLs
        if 'youtube.com' in parsed_url.netloc or 'youtu.be' in parsed_url.netloc:
            query_params = urlparse.parse_qs(parsed_url.query)
            # Keep only the video ID and essential parameters
            cleaned_params = {}
            if 'v' in query_params:
                cleaned_params['v'] = query_params['v']
            elif 't' in query_params:  # Keep time parameter if present
                cleaned_params['t'] = query_params['t']
            
            # Rebuild clean URL
            clean_query = urlparse.urlencode(cleaned_params, doseq=True)
            clean_url = urlparse.urlunparse((
                parsed_url.scheme,
                parsed_url.netloc, 
                parsed_url.path,
                parsed_url.params,
                clean_query,
                parsed_url.fragment
            ))
            
            # For youtu.be URLs, extract video ID from path
            if 'youtu.be' in parsed_url.netloc and parsed_url.path:
                video_id = parsed_url.path.lstrip('/')
                clean_url = f"https://www.youtube.com/watch?v={video_id}"
            
            logging.info(f"Cleaned URL from '{video_url}' to '{clean_url}'")
            video_url = clean_url
        
        # Emit initial status
        progress_data = {
            'progress': '0',
            'percentage': '0%',
            'type': 'audio',
            'status': 'downloading'
        }
        socketio.emit('progress', progress_data)
        socketio.emit('percentage', {'percentage': '0%'})
        
        # Check if download path exists or try to get default path
        if not download_path:
            download_path = get_default_download_path(socketio)
            if not download_path:
                error_msg = "Could not determine download path. Please open a Premiere Pro project."
                logging.error(error_msg)
                socketio.emit('download-failed', {'message': error_msg})
                return None
                
        logging.info(f"Using download path for audio: {download_path}")
        
        # Ensure the path exists
        try:
            os.makedirs(download_path, exist_ok=True)
            logging.info(f"Ensured download directory exists: {download_path}")
        except Exception as e:
            error_msg = f"Could not create download directory: {str(e)}"
            logging.error(error_msg)
            socketio.emit('download-failed', {'message': error_msg})
            return None

        # Get preferred audio language from settings
        preferred_language = 'original'
        if settings:
            preferred_language = settings.get('preferredAudioLanguage', 'original')
        logging.info(f"Using preferred audio language for audio download: {preferred_language}")
        
        # Configure format selector based on language preference
        if preferred_language != 'original':
            audio_format = f'bestaudio[language~="{preferred_language}"]/bestaudio/best'
        else:
            audio_format = 'bestaudio/best'
        
        # Progress throttling variables for audio
        last_progress_time_audio = [0]  # Use list to make it mutable in nested function
        last_progress_value_audio = [0]
        
        # Simple progress hook like the old working version
        def progress_hook(d):
            if d['status'] == 'downloading':
                try:
                    percentage = d.get('_percent_str', '0%')
                    # Remove ANSI color codes if present
                    percentage = re.sub(r'\x1B\[[0-?]*[ -/]*[@-~]', '', percentage)
                    percentage = percentage.strip()
                    logging.info(f'[PROGRESS] Audio Progress: {percentage}')
                    # Simple emission like the old version
                    socketio.emit('percentage', {'percentage': percentage})
                except Exception as e:
                    logging.error(f"Error in audio progress hook: {e}")
            elif d['status'] == 'finished':
                logging.info('[FINISHED] Audio download finished')
                socketio.emit('percentage', {'percentage': '100%'})

        # Configure yt-dlp options with robust settings for audio download
        ydl_opts = get_robust_ydl_options(ffmpeg_path)
        ydl_opts.update({
            'format': audio_format,
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'wav',
            }],
            'progress_hooks': [progress_hook],
            'writesubtitles': False,  # Don't download subtitles for audio
            'writeautomaticsub': False,  # Don't download auto subtitles
            'writedescription': False,  # Don't write description
            'writeinfojson': False,  # Don't write info JSON
            'writethumbnail': False,  # Don't download thumbnail
            'postprocessor_args': get_ffmpeg_postprocessor_args() + [
                '-metadata', f'comment={video_url}',
                '-threads', '4'  # Limit threads to avoid resource issues
            ],
        })
        
        # Apply authentication for audio download
        cookies_file = None
        if cookies:
            cookies_file = create_cookies_file(cookies)
            if not cookies_file:
                cookies_file = get_youtube_cookies_file()
        else:
            cookies_file = get_youtube_cookies_file()
            if not cookies_file:
                browser_cookies = try_extract_cookies_from_browser()
                if browser_cookies:
                    ydl_opts['cookiesfrombrowser'] = browser_cookies
                    logging.info(f"Using cookies from browser for audio download: {browser_cookies[0]}")
        
        if cookies_file and os.path.exists(cookies_file):
            ydl_opts['cookiefile'] = cookies_file
            logging.info(f"Using cookies file for audio download: {cookies_file}")
        
        if user_agent:
            ydl_opts['http_headers'] = {'User-Agent': user_agent}
            logging.info("Using User-Agent from extension for audio download")

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            try:
                # Extract info first to verify URL is valid and get title
                logging.info(f"Attempting to extract info for URL: {video_url}")
                info = ydl.extract_info(video_url, download=False)
                
                if not info:
                    error_msg = "Could not extract video information - yt-dlp returned None"
                    logging.error(error_msg)
                    logging.error(f"URL used: {video_url}")
                    logging.error(f"yt-dlp options: {ydl_opts}")
                    raise Exception(error_msg)
                
                # Log extracted info for debugging
                logging.info(f"Successfully extracted info for: {info.get('title', 'Unknown title')}")
                logging.info(f"Video ID: {info.get('id', 'Unknown ID')}")
                logging.info(f"Duration: {info.get('duration', 'Unknown duration')} seconds")
                
                # Verify this is actually a video and not a playlist or channel
                if info.get('_type') == 'playlist':
                    error_msg = "URL points to a playlist, not a single video. Please use a direct video URL."
                    logging.error(error_msg)
                    raise Exception(error_msg)
                
                # Check if audio formats are available
                formats = info.get('formats', [])
                audio_formats = [f for f in formats if f.get('acodec') != 'none']
                if not audio_formats:
                    error_msg = "No audio formats available for this video"
                    logging.error(error_msg)
                    raise Exception(error_msg)

                # Create unique filename
                title = info.get('title', 'audio')
                sanitized_title = sanitize_youtube_title(title)
                output_path = os.path.join(download_path, f"{sanitized_title}.wav")

                # Ensure directory exists
                os.makedirs(download_path, exist_ok=True)

                # Remove existing temp files if any
                temp_pattern = os.path.join(download_path, f"temp_{sanitized_title}*")
                for temp_file in glob.glob(temp_pattern):
                    try:
                        os.remove(temp_file)
                    except:
                        pass

                # Set output template after getting info
                ydl_opts['outtmpl'] = os.path.join(download_path, f'temp_{sanitized_title}')
                
                # Create new YoutubeDL instance with updated options
                with yt_dlp.YoutubeDL(ydl_opts) as ydl_download:
                    # Download using the already extracted info
                    ydl_download.process_ie_result(info, download=True)

                # Find the downloaded file
                downloaded_file = None
                for file in os.listdir(download_path):
                    if file.startswith('temp_') and file.endswith('.wav'):
                        downloaded_file = os.path.join(download_path, file)
                        break

                if not downloaded_file:
                    raise Exception("Could not find downloaded audio file")

                # Add metadata using ffmpeg
                temp_output = output_path + "_with_metadata.wav"
                metadata_cmd = [
                    ffmpeg_path,
                    '-i', downloaded_file,
                    '-metadata', f'comment={video_url}',
                ] + get_ffmpeg_postprocessor_args() + [
                    temp_output
                ]

                run_hidden_subprocess(metadata_cmd, check=True)

                # Clean up and rename
                try:
                    os.remove(downloaded_file)
                except:
                    pass

                try:
                    os.rename(temp_output, output_path)
                except:
                    # If rename fails, try copy and delete
                    import shutil
                    shutil.copy2(temp_output, output_path)
                    try:
                        os.remove(temp_output)
                    except:
                        pass

                # Emit both completion events before returning
                if socketio:
                    socketio.emit('import_video', {'path': output_path})
                    # Emit both formats to ensure compatibility
                    socketio.emit('download-complete', {'url': video_url, 'path': output_path})  # Hyphenated format for Chrome extension

                return output_path

            except Exception as e:
                logging.error(f"Error downloading audio: {str(e)}")
                logging.error(f"Exception type: {type(e)}")
                logging.error(f"Exception traceback: {traceback.format_exc()}")
                if socketio:
                    socketio.emit('download-failed', {'message': f'Error downloading audio: {str(e)}'})
                return None

    except Exception as e:
        logging.error(f"Error in download_audio: {str(e)}")
        if socketio:
            socketio.emit('download-failed', {'message': str(e)})
        return None

def format_timestamp(seconds):
    """Convert seconds to HH:MM:SS format"""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    seconds = seconds % 60
    return f"{int(hours):02d}:{int(minutes):02d}:{int(seconds):02d}"

def get_audio_format_selector(preferred_language='original'):
    """
    Create a format selector string for yt-dlp that prefers a specific audio language
    with fallback to original audio if the preferred language is not available.
    """
    if preferred_language == 'original':
        # Return the original best format selector
        return 'bestvideo+bestaudio/best'
    
    # Language mapping for common cases
    language_codes = {
        'en': ['en', 'eng', 'english'],
        'fr': ['fr', 'fre', 'fra', 'french', 'français'],
        'es': ['es', 'spa', 'spanish', 'español'],
        'de': ['de', 'ger', 'deu', 'german', 'deutsch'],
        'it': ['it', 'ita', 'italian', 'italiano'],
        'pt': ['pt', 'por', 'portuguese', 'português'],
        'ru': ['ru', 'rus', 'russian', 'русский'],
        'ja': ['ja', 'jpn', 'japanese', '日本語'],
        'ko': ['ko', 'kor', 'korean', '한국어'],
        'zh': ['zh', 'chi', 'zho', 'chinese', '中文'],
        'ar': ['ar', 'ara', 'arabic', 'العربية'],
        'hi': ['hi', 'hin', 'hindi', 'हिन्दी']
    }
    
    # Get all possible language codes for the preferred language
    lang_variants = language_codes.get(preferred_language, [preferred_language])
    
    # Create format selector that prefers the specified language
    # Format: try language-specific audio + best video, fallback to original best
    lang_conditions = '|'.join(lang_variants)
    format_selector = f'bestvideo+bestaudio[language~="{lang_conditions}"]/bestvideo+bestaudio/best'
    
    return format_selector

def get_audio_language_options(video_url):
    """
    Extract available audio language options from a YouTube video.
    Returns a list of available languages.
    """
    try:
        with yt_dlp.YoutubeDL({'quiet': True}) as ydl:
            info = ydl.extract_info(video_url, download=False)
            if not info:
                return []
            
            available_languages = set()
            formats = info.get('formats', [])
            
            for fmt in formats:
                if fmt.get('acodec') != 'none':  # Audio format
                    lang = fmt.get('language')
                    if lang:
                        available_languages.add(lang)
            
            return sorted(list(available_languages))
    except Exception as e:
        logging.error(f"Error extracting audio languages: {str(e)}")
        return []

def write_error_log(error_message, context=None):
    """Write error to dedicated error log file"""
    try:
        log_dir = os.environ.get('YTPP_LOG_DIR')
        if not log_dir:
            return
        
        error_log_path = os.path.join(log_dir, 'video_processing_errors.log')
        
        from datetime import datetime
        timestamp = datetime.now().isoformat()
        
        with open(error_log_path, 'a', encoding='utf-8') as f:
            f.write(f"\n[{timestamp}] ERROR: {error_message}\n")
            if context:
                f.write(f"Context: {json.dumps(context, indent=2)}\n")
            f.write("-" * 50 + "\n")
    except Exception as e:
        logging.error(f"Failed to write to error log: {e}")

def get_ffmpeg_location_for_ydl(ffmpeg_path):
    """Get the correct FFmpeg location configuration for yt-dlp"""
    if not ffmpeg_path:
        return None
    
    if sys.platform == 'win32':
        # On Windows, yt-dlp expects the full path to the executable
        return ffmpeg_path
    else:
        # On Unix systems (macOS/Linux)
        if ffmpeg_path == 'ffmpeg':
            # If it's just 'ffmpeg', it's in PATH - don't set ffmpeg_location
            # yt-dlp will find it automatically
            return None
        elif os.path.isabs(ffmpeg_path):
            # If it's an absolute path, return the directory containing it
            ffmpeg_dir = os.path.dirname(ffmpeg_path)
            if ffmpeg_dir and ffmpeg_dir != '/' and ffmpeg_dir != '.':
                return ffmpeg_dir
            else:
                return None
        else:
            # Relative path - return as-is and let yt-dlp handle it
            return ffmpeg_path

def get_robust_ydl_options(ffmpeg_path, cookies_file=None, user_agent=None):
    """Get robust yt-dlp options to handle YouTube changes and SABR streaming"""
    base_options = {
        'quiet': False,  # Enable output to see what's happening
        'no_warnings': False,  # Show warnings for debugging
        'age_limit': None,  # Don't apply age limits
        'geo_bypass': True,  # Bypass geographic restrictions
        'geo_bypass_country': 'US',  # Use US as bypass country
        'nocheckcertificate': True,  # Skip certificate validation
        'extractor_retries': 10,  # Increase retry count
        'retry_sleep': lambda n: min(5 * (n + 1), 30),  # Exponential backoff with max 30s
        'socket_timeout': 60,  # Increase socket timeout
        'fragment_retries': 10,  # Retry fragment downloads
        'file_access_retries': 5,  # Retry file access operations
        'ignoreerrors': False,  # Don't ignore errors during extraction
        'extract_flat': False,  # Don't use flat extraction
        'playlistend': 1,  # Only download first video if URL is accidentally a playlist
        'playliststart': 1,  # Start from first video
        'noplaylist': True,  # Explicitly ignore playlists
        
        # Progress tracking improvements
        'consoletitle': True,  # Update console title with progress
        'noprogress': False,  # Enable progress reporting
        'progress_with_newline': False,  # Use same line for progress
        
        # YouTube-specific options to handle SABR and signature issues
        'youtube_include_dash_manifest': True,  # Include DASH manifest
        'youtube_include_hls_manifest': True,   # Include HLS manifest
        'youtube_skip_dash_manifest': False,    # Don't skip DASH manifest
        'youtube_skip_hls_manifest': False,     # Don't skip HLS manifest
        'extractor_args': {
            'youtube': {
                'player_client': ['android', 'web', 'tv_embedded'],  # Try multiple clients (removed mediaconnect as it's unsupported)
                'player_skip': [],  # Don't skip any players
                'skip': [],  # Don't skip any extractors
            }
        },
        
        # FFmpeg configuration - handle both absolute paths and PATH resolution
        'ffmpeg_location': get_ffmpeg_location_for_ydl(ffmpeg_path),
        'postprocessor_args': get_ffmpeg_postprocessor_args() + ['-threads', '4'],
        'external_downloader_args': ['-timeout', '120'],  # Increase timeout
    }
    
    # Add authentication if available
    if cookies_file:
        base_options['cookiefile'] = cookies_file
        logging.info(f"Using cookies file: {cookies_file}")
    
    if user_agent:
        base_options['http_headers'] = {'User-Agent': user_agent}
        logging.info("Using custom User-Agent")
    
    return base_options

def get_fallback_format_options(max_height):
    """Get fallback format options that are more likely to work with current YouTube"""
    # Start with the most compatible formats that work with SABR streaming
    format_options = [
        # Try mobile/TV formats first (often work better with SABR)
        f'best[height<={max_height}][protocol^=https]',  # HTTPS only
        f'best[height<={max_height}][protocol!=http_dash_segments]',  # Avoid problematic DASH
        f'bestvideo[height<={max_height}][protocol^=https]+bestaudio[protocol^=https]',
        f'bestvideo[height<={max_height}]+bestaudio',
        
        # Fallback to any working format
        f'best[height<={max_height}]',
        'best[protocol^=https]',  # Any HTTPS format
        'best[protocol!=http_dash_segments]',  # Avoid problematic protocols
        'best',  # Last resort - any format
        
        # Emergency fallbacks
        'worst[height>=360]',  # At least 360p
        'worst',  # Absolute last resort
    ]
    
    return format_options

# Main execution
if __name__ == "__main__":
    # Add any additional setup if necessary
    logging.basicConfig(level=logging.INFO)
    logging.info("Script started")
